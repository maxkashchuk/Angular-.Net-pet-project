{"ast":null,"code":"import { __decorate } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, ElementRef, Component, ChangeDetectionStrategy, Inject, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport * as i1 from '@alyle/ui';\nimport { st2c, StyleCollection, LY_COMMON_STYLES, mergeDeep, StyleRenderer, Style2 } from '@alyle/ui';\nimport { Subject, Observable } from 'rxjs';\nimport { takeUntil, take } from 'rxjs/operators';\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\nimport * as i3 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport * as i2 from '@angular/cdk/scrolling';\n/*\n * Hermite resize - fast image resize/resample using Hermite filter.\n * https://github.com/viliusle/Hermite-resize\n */\n\nconst _c0 = [\"_imgContainer\"];\nconst _c1 = [\"_area\"];\nconst _c2 = [\"_imgCanvas\"];\n\nconst _c3 = function (a0, a1) {\n  return {\n    width: a0,\n    height: a1\n  };\n};\n\nfunction LyImageCropper_ly_cropper_area_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ly-cropper-area\", 5, 6);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"round\", !!ctx_r2.config.round)(\"resizableArea\", !!ctx_r2.config.resizableArea)(\"keepAspectRatio\", !!ctx_r2.config.keepAspectRatio)(\"ngStyle\", i0.ɵɵpureFunction2(4, _c3, ctx_r2.config.width + \"px\", ctx_r2.config.height + \"px\"));\n  }\n}\n\nfunction LyImageCropper_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 7)(1, \"input\", 8, 9);\n    i0.ɵɵlistener(\"change\", function LyImageCropper_ng_template_5_Template_input_change_1_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.selectInputEvent($event));\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵprojection(3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"className\", ctx_r4.classes.defaultContent);\n  }\n}\n\nconst _c4 = [\"*\"];\nconst _c5 = [\"resizer\"];\n\nfunction LyCropperArea_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", null, 1);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r0.classes.resizer);\n  }\n}\n\nfunction resizeCanvas(canvas, width, height) {\n  const width_source = canvas.width;\n  const height_source = canvas.height;\n  width = Math.round(width);\n  height = Math.round(height);\n  const ratio_w = width_source / width;\n  const ratio_h = height_source / height;\n  const ratio_w_half = Math.ceil(ratio_w / 2);\n  const ratio_h_half = Math.ceil(ratio_h / 2);\n  const ctx = canvas.getContext('2d');\n  const img = ctx.getImageData(0, 0, width_source, height_source);\n  const img2 = ctx.createImageData(width, height);\n  const data = img.data;\n  const data2 = img2.data;\n\n  for (let j = 0; j < height; j++) {\n    for (let i = 0; i < width; i++) {\n      const x2 = (i + j * width) * 4;\n      let weight = 0;\n      let weights = 0;\n      let weights_alpha = 0;\n      let gx_r = 0;\n      let gx_g = 0;\n      let gx_b = 0;\n      let gx_a = 0;\n      const center_y = j * ratio_h;\n      const xx_start = Math.floor(i * ratio_w);\n      let xx_stop = Math.ceil((i + 1) * ratio_w);\n      const yy_start = Math.floor(j * ratio_h);\n      let yy_stop = Math.ceil((j + 1) * ratio_h);\n      xx_stop = Math.min(xx_stop, width_source);\n      yy_stop = Math.min(yy_stop, height_source);\n\n      for (let yy = yy_start; yy < yy_stop; yy++) {\n        const dy = Math.abs(center_y - yy) / ratio_h_half;\n        const center_x = i * ratio_w;\n        const w0 = dy * dy; // pre-calc part of w\n\n        for (let xx = xx_start; xx < xx_stop; xx++) {\n          const dx = Math.abs(center_x - xx) / ratio_w_half;\n          const w = Math.sqrt(w0 + dx * dx);\n\n          if (w >= 1) {\n            // pixel too far\n            continue;\n          } // hermite filter\n\n\n          weight = 2 * w * w * w - 3 * w * w + 1;\n          const pos_x = 4 * (xx + yy * width_source); // alpha\n\n          gx_a += weight * data[pos_x + 3];\n          weights_alpha += weight; // colors\n\n          if (data[pos_x + 3] < 255) {\n            weight = weight * data[pos_x + 3] / 250;\n          }\n\n          gx_r += weight * data[pos_x];\n          gx_g += weight * data[pos_x + 1];\n          gx_b += weight * data[pos_x + 2];\n          weights += weight;\n        }\n      }\n\n      data2[x2] = gx_r / weights;\n      data2[x2 + 1] = gx_g / weights;\n      data2[x2 + 2] = gx_b / weights;\n      data2[x2 + 3] = gx_a / weights_alpha;\n    }\n  } // clear and resize canvas\n\n\n  canvas.width = width;\n  canvas.height = height; // draw\n\n  ctx.putImageData(img2, 0, 0);\n  return ctx;\n}\n\nconst activeEventOptions = normalizePassiveListenerOptions({\n  passive: false\n});\nconst STYLE_PRIORITY = -2;\nconst DATA_IMAGE_SVG_PREFIX = 'data:image/svg+xml;base64,';\nconst pos = (100 * Math.sqrt(2) - 100) / 2 / Math.sqrt(2);\n\nconst STYLES = (theme, ref) => {\n  const cropper = ref.selectorsOf(STYLES);\n  const {\n    after\n  } = theme;\n  return {\n    $name: LyImageCropper.и,\n    $priority: STYLE_PRIORITY,\n    root: () => _className => `${_className}{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;overflow:hidden;position:relative;justify-content:center;align-items:center;}${st2c(theme.cropper && theme.cropper.root && (theme.cropper.root instanceof StyleCollection ? theme.cropper.root.setTransformer(fn => fn(cropper)) : theme.cropper.root(cropper)), `${_className}`)}`,\n    imgContainer: _className => `${_className}{cursor:move;position:absolute;top:0;left:0;display:flex;touch-action:none;}${_className} > canvas{display:block;}`,\n    overlay: _className => `${st2c(LY_COMMON_STYLES.fill, `${_className}`)}`,\n    area: _className => `${_className}{pointer-events:none;box-shadow:0 0 0 20000px rgba(0,0,0,0.4);}${st2c(LY_COMMON_STYLES.fill, `${_className}`)}${_className}{margin:auto;}${st2c(LY_COMMON_STYLES.fill, `${_className}:before,${_className}:after`)}${_className}:before,${_className}:after{content:'';}${_className}:before{width:0;height:0;margin:auto;border-radius:50%;background:#fff;border:solid 2px rgb(255,255,255);}${_className}:after{border:solid 2px rgb(255,255,255);border-radius:inherit;}`,\n    resizer: _className => `${_className}{width:10px;height:10px;background:#fff;border-radius:3px;position:absolute;touch-action:none;bottom:0;${after}:0;pointer-events:all;cursor:${after === 'right' ? 'nwse-resize' : 'nesw-resize'};}${st2c(LY_COMMON_STYLES.fill, `${_className}:before`)}${_className}:before{content:'';width:20px;height:20px;transform:translate(-25%,-25%);}`,\n    defaultContent: _className => `${_className}{display:flex;align-items:center;justify-content:center;}${st2c(LY_COMMON_STYLES.fill, `${_className},${_className} > input`)}${_className} *:not(input){pointer-events:none;}${_className} > input{background:transparent;opacity:0;width:100%;height:100%;}`\n  };\n};\n/** Image Cropper Config */\n\n\nclass ImgCropperConfig {\n  constructor() {\n    /** Cropper area width */\n    this.width = 250;\n    /** Cropper area height */\n\n    this.height = 200;\n    this.minWidth = 40;\n    this.minHeight = 40;\n    /**\n     * Set anti-aliased (default: true)\n     * @deprecated this is not necessary as the cropper will automatically resize the image\n     * to the best quality\n     */\n\n    this.antiAliased = true;\n    this.output = ImgResolution.Default;\n  }\n\n}\n/** Image output */\n\n\nvar ImgResolution = /*#__PURE__*/(() => {\n  (function (ImgResolution) {\n    /**\n     * The output image will be equal to the initial size of the cropper area.\n     */\n    ImgResolution[ImgResolution[\"Default\"] = 0] = \"Default\";\n    /** Just crop the image without resizing */\n\n    ImgResolution[ImgResolution[\"OriginalImage\"] = 1] = \"OriginalImage\";\n  })(ImgResolution || (ImgResolution = {}));\n\n  return ImgResolution;\n})();\n\n/** Image output */\nvar ImgCropperError = /*#__PURE__*/(() => {\n  (function (ImgCropperError) {\n    /** The loaded image exceeds the size limit set. */\n    ImgCropperError[ImgCropperError[\"Size\"] = 0] = \"Size\";\n    /** The file loaded is not image. */\n\n    ImgCropperError[ImgCropperError[\"Type\"] = 1] = \"Type\";\n    /** When the image has not been loaded. */\n\n    ImgCropperError[ImgCropperError[\"Other\"] = 2] = \"Other\";\n  })(ImgCropperError || (ImgCropperError = {}));\n\n  return ImgCropperError;\n})();\nlet LyImageCropper = /*#__PURE__*/(() => {\n  class LyImageCropper {\n    constructor(sRenderer, _renderer, _elementRef, cd, _ngZone, _document, viewPortRuler) {\n      this.sRenderer = sRenderer;\n      this._renderer = _renderer;\n      this._elementRef = _elementRef;\n      this.cd = cd;\n      this._ngZone = _ngZone;\n      /**\n       * styles\n       * @docs-private\n       */\n\n      this.classes = this.sRenderer.renderSheet(STYLES, true);\n      this._imgRect = {};\n      this._rotation = 0;\n      this.scaleChange = new EventEmitter();\n      /** Emits minimum supported image scale */\n\n      this.minScaleChange = new EventEmitter();\n      /** Emits maximum supported image scale */\n\n      this.maxScaleChange = new EventEmitter();\n      /** @deprecated Emits when the image is loaded, instead use `ready` */\n\n      this.loaded = new EventEmitter();\n      /** Emits when the image is loaded */\n\n      this.imageLoaded = new EventEmitter();\n      /** Emits when the cropper is ready to be interacted */\n\n      this.ready = new EventEmitter();\n      /** On crop new image */\n\n      this.cropped = new EventEmitter();\n      /** Emits when the cropper is cleaned */\n\n      this.cleaned = new EventEmitter();\n      /** Emit an error when the loaded image is not valid */\n      // tslint:disable-next-line: no-output-native\n\n      this.error = new EventEmitter();\n      /** Emits whenever the component is destroyed. */\n\n      this._destroy = new Subject();\n\n      this._pointerDown = event => {\n        // Don't do anything if the\n        // user is using anything other than the main mouse button.\n        if (this._isSliding || !isTouchEvent(event) && event.button !== 0) {\n          return;\n        }\n\n        this._ngZone.run(() => {\n          this._isSliding = true;\n          this.offset = {\n            x: this._imgRect.x,\n            y: this._imgRect.y,\n            left: this._imgRect.xc,\n            top: this._imgRect.yc\n          };\n          this._lastPointerEvent = event;\n          this._startPointerEvent = getGesturePointFromEvent(event);\n          event.preventDefault();\n\n          this._bindGlobalEvents(event);\n        });\n      };\n      /**\n       * Called when the user has moved their pointer after\n       * starting to drag.\n       */\n\n\n      this._pointerMove = event => {\n        if (this._isSliding) {\n          event.preventDefault();\n          this._lastPointerEvent = event;\n          let x, y;\n          const canvas = this._imgCanvas.nativeElement;\n          const scaleFix = this._scal3Fix;\n          const config = this.config;\n          const startP = this.offset;\n          const point = getGesturePointFromEvent(event);\n          const deltaX = point.x - this._startPointerEvent.x;\n          const deltaY = point.y - this._startPointerEvent.y;\n\n          if (!scaleFix || !startP) {\n            return;\n          }\n\n          const isMinScaleY = canvas.height * scaleFix < config.height && config.extraZoomOut;\n          const isMinScaleX = canvas.width * scaleFix < config.width && config.extraZoomOut;\n          const limitLeft = config.width / 2 / scaleFix >= startP.left - deltaX / scaleFix;\n          const limitRight = config.width / 2 / scaleFix + canvas.width - (startP.left - deltaX / scaleFix) <= config.width / scaleFix;\n          const limitTop = config.height / 2 / scaleFix >= startP.top - deltaY / scaleFix;\n          const limitBottom = config.height / 2 / scaleFix + canvas.height - (startP.top - deltaY / scaleFix) <= config.height / scaleFix; // Limit for left\n\n          if (limitLeft && !isMinScaleX || !limitLeft && isMinScaleX) {\n            x = startP.x + startP.left - config.width / 2 / scaleFix;\n          } // Limit for right\n\n\n          if (limitRight && !isMinScaleX || !limitRight && isMinScaleX) {\n            x = startP.x + startP.left + config.width / 2 / scaleFix - canvas.width;\n          } // Limit for top\n\n\n          if (limitTop && !isMinScaleY || !limitTop && isMinScaleY) {\n            y = startP.y + startP.top - config.height / 2 / scaleFix;\n          } // Limit for bottom\n\n\n          if (limitBottom && !isMinScaleY || !limitBottom && isMinScaleY) {\n            y = startP.y + startP.top + config.height / 2 / scaleFix - canvas.height;\n          } // When press shiftKey, deprecated\n          // if (event.srcEvent && event.srcEvent.shiftKey) {\n          //   if (Math.abs(event.deltaX) === Math.max(Math.abs(event.deltaX), Math.abs(event.deltaY))) {\n          //     y = this.offset.top;\n          //   } else {\n          //     x = this.offset.left;\n          //   }\n          // }\n\n\n          if (x === void 0) {\n            x = deltaX / scaleFix + startP.x;\n          }\n\n          if (y === void 0) {\n            y = deltaY / scaleFix + startP.y;\n          }\n\n          this._setStylesForContImg({\n            x,\n            y\n          });\n        }\n      };\n      /** Called when the user has lifted their pointer. */\n\n\n      this._pointerUp = event => {\n        if (this._isSliding) {\n          event.preventDefault();\n\n          this._removeGlobalEvents();\n\n          this._isSliding = false;\n          this._startPointerEvent = null;\n\n          this._cropIfAutoCrop();\n        }\n      };\n      /** Called when the window has lost focus. */\n\n\n      this._windowBlur = () => {\n        // If the window is blurred while dragging we need to stop dragging because the\n        // browser won't dispatch the `mouseup` and `touchend` events anymore.\n        if (this._lastPointerEvent) {\n          this._pointerUp(this._lastPointerEvent);\n        }\n      };\n\n      this._document = _document;\n      viewPortRuler.change().pipe(takeUntil(this._destroy)).subscribe(() => this._ngZone.run(() => this.updateCropperPosition()));\n    }\n\n    get config() {\n      return this._config;\n    }\n\n    set config(val) {\n      this._config = mergeDeep({}, new ImgCropperConfig(), val);\n      this._configPrimary = mergeDeep({}, this._config);\n      this._primaryAreaWidth = this.config.width;\n      this._primaryAreaHeight = this.config.height;\n\n      if (this._config.round && this.config.width !== this.config.height) {\n        throw new Error(`${LyImageCropper.и}: Both width and height must be equal when using \\`ImgCropperConfig.round = true\\``);\n      }\n\n      const maxFileSize = this._config.maxFileSize;\n\n      if (maxFileSize) {\n        this.maxFileSize = maxFileSize;\n      }\n    }\n    /** Set scale */\n\n\n    get scale() {\n      return this._scale;\n    }\n\n    set scale(val) {\n      this.setScale(val);\n    }\n    /** Get min scale */\n\n\n    get minScale() {\n      return this._minScale;\n    }\n\n    ngOnInit() {\n      this._ngZone.runOutsideAngular(() => {\n        const element = this._imgContainer.nativeElement;\n        element.addEventListener('mousedown', this._pointerDown, activeEventOptions);\n        element.addEventListener('touchstart', this._pointerDown, activeEventOptions);\n      });\n    }\n\n    ngOnDestroy() {\n      this._destroy.next();\n\n      this._destroy.complete();\n\n      const element = this._imgContainer.nativeElement;\n      this._lastPointerEvent = null;\n\n      this._removeGlobalEvents();\n\n      element.removeEventListener('mousedown', this._pointerDown, activeEventOptions);\n      element.removeEventListener('touchstart', this._pointerDown, activeEventOptions);\n    }\n    /** Load image with canvas */\n\n\n    _imgLoaded(imgElement) {\n      if (imgElement) {\n        this._img = imgElement;\n        const canvas = this._imgCanvas.nativeElement;\n        canvas.width = imgElement.width;\n        canvas.height = imgElement.height;\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, imgElement.width, imgElement.height);\n        ctx.drawImage(imgElement, 0, 0);\n        /** set min scale */\n\n        this._updateMinScale(canvas);\n\n        this._updateMaxScale();\n      }\n    }\n\n    _setStylesForContImg(values) {\n      const newStyles = {};\n\n      if (values.x != null && values.y != null) {\n        const rootRect = this._rootRect();\n\n        const x = rootRect.width / 2 - values.x;\n        const y = rootRect.height / 2 - values.y;\n        this._imgRect.x = values.x;\n        this._imgRect.y = values.y;\n        this._imgRect.xc = x;\n        this._imgRect.yc = y;\n      }\n\n      newStyles.transform = `translate3d(${this._imgRect.x}px,${this._imgRect.y}px, 0)`;\n      newStyles.transform += `scale(${this._scal3Fix})`;\n      newStyles.transformOrigin = `${this._imgRect.xc}px ${this._imgRect.yc}px 0`;\n      newStyles['-webkit-transform'] = newStyles.transform;\n      newStyles['-webkit-transform-origin'] = newStyles.transformOrigin;\n\n      for (const key in newStyles) {\n        if (newStyles.hasOwnProperty(key)) {\n          this._renderer.setStyle(this._imgContainer.nativeElement, key, newStyles[key]);\n        }\n      }\n    }\n    /**\n     * Update area and image position only if needed,\n     * this is used when window resize\n     */\n\n\n    updateCropperPosition() {\n      if (this.isLoaded) {\n        this.updatePosition();\n\n        this._updateAreaIfNeeded();\n      }\n    }\n    /** Load Image from input event */\n\n\n    selectInputEvent(img) {\n      this._currentInputElement = img.target;\n      const _img = img.target;\n\n      if (_img.files && _img.files.length !== 1) {\n        return;\n      }\n\n      const fileSize = _img.files[0].size;\n\n      const fileName = _img.value.replace(/.*(\\/|\\\\)/, '');\n\n      if (this.maxFileSize && fileSize > this.maxFileSize) {\n        const cropEvent = {\n          name: fileName,\n          type: _img.files[0].type,\n          size: fileSize,\n          error: ImgCropperError.Size\n        };\n        this.clean();\n        this.error.emit(cropEvent);\n        return;\n      }\n\n      new Observable(observer => {\n        const reader = new FileReader();\n\n        reader.onerror = err => observer.error(err);\n\n        reader.onabort = err => observer.error(err);\n\n        reader.onload = ev => setTimeout(() => {\n          observer.next(ev);\n          observer.complete();\n        });\n\n        reader.readAsDataURL(_img.files[0]);\n      }).pipe(take(1), takeUntil(this._destroy)).subscribe(loadEvent => {\n        const originalDataURL = loadEvent.target.result;\n        this.loadImage({\n          name: fileName,\n          size: _img.files[0].size,\n          type: this.config.type || _img.files[0].type,\n          originalDataURL\n        });\n        this.cd.markForCheck();\n      }, () => {\n        const cropEvent = {\n          name: fileName,\n          size: fileSize,\n          error: ImgCropperError.Other,\n          errorMsg: 'The File could not be loaded.',\n          type: _img.files[0].type\n        };\n        this.clean();\n        this.error.emit(cropEvent);\n      });\n    }\n    /** Set the size of the image, the values can be 0 between 1, where 1 is the original size */\n\n\n    setScale(size, noAutoCrop) {\n      // fix min scale\n      const newSize = size >= this.minScale && size <= 1 ? size : this.minScale; // check\n\n      const changed = size != null && size !== this.scale && newSize !== this.scale;\n      this._scale = size;\n\n      if (!changed) {\n        return;\n      }\n\n      this._scal3Fix = newSize;\n\n      this._updateAbsoluteScale();\n\n      if (this.isLoaded) {\n        if (changed) {\n          const originPosition = Object.assign({}, this._imgRect);\n          this.offset = {\n            x: originPosition.x,\n            y: originPosition.y,\n            left: originPosition.xc,\n            top: originPosition.yc\n          };\n\n          this._setStylesForContImg({});\n\n          this._simulatePointerMove();\n        } else {\n          return;\n        }\n      } else if (this.minScale) {\n        this._setStylesForContImg(Object.assign({}, this._getCenterPoints()));\n      } else {\n        return;\n      }\n\n      this.scaleChange.emit(size);\n\n      if (!noAutoCrop) {\n        this._cropIfAutoCrop();\n      }\n    }\n\n    _getCenterPoints() {\n      const root = this._elementRef.nativeElement;\n      const img = this._imgCanvas.nativeElement;\n      const x = (root.offsetWidth - img.width) / 2;\n      const y = (root.offsetHeight - img.height) / 2;\n      return {\n        x,\n        y\n      };\n    }\n    /**\n     * Fit to screen\n     */\n\n\n    fitToScreen() {\n      const container = this._elementRef.nativeElement;\n      const min = {\n        width: container.offsetWidth,\n        height: container.offsetHeight\n      };\n      const {\n        width,\n        height\n      } = this._img;\n      const minScale = {\n        width: min.width / width,\n        height: min.height / height\n      };\n      const result = Math.max(minScale.width, minScale.height);\n      this.setScale(result);\n    }\n\n    fit() {\n      this.setScale(this.minScale);\n    }\n    /**\n     * Simulate pointerMove with clientX = 0 and clientY = 0,\n     * this is used by `setScale` and `rotate`\n     */\n\n\n    _simulatePointerMove() {\n      this._isSliding = true;\n      this._startPointerEvent = {\n        x: 0,\n        y: 0\n      };\n\n      this._pointerMove({\n        clientX: 0,\n        clientY: 0,\n        type: 'n',\n        preventDefault: () => {}\n      });\n\n      this._isSliding = false;\n      this._startPointerEvent = null;\n    }\n\n    _markForCheck() {\n      this.cd.markForCheck();\n    }\n\n    updatePosition(xOrigin, yOrigin) {\n      const hostRect = this._rootRect();\n\n      const areaRect = this._areaCropperRect();\n\n      const areaWidth = areaRect.width > hostRect.width ? hostRect.width : areaRect.width;\n      const areaHeight = areaRect.height > hostRect.height ? hostRect.height : areaRect.height;\n      let x, y;\n\n      if (xOrigin == null && yOrigin == null) {\n        xOrigin = this._imgRect.xc;\n        yOrigin = this._imgRect.yc;\n      }\n\n      x = areaRect.left - hostRect.left;\n      y = areaRect.top - hostRect.top;\n      x -= xOrigin - areaWidth / 2;\n      y -= yOrigin - areaHeight / 2;\n\n      this._setStylesForContImg({\n        x,\n        y\n      });\n    }\n\n    _slideEnd() {\n      this._cropIfAutoCrop();\n    }\n\n    _cropIfAutoCrop() {\n      if (this.config.autoCrop) {\n        this.crop();\n      }\n    }\n    /** + */\n\n\n    zoomIn() {\n      const scale = this._scal3Fix + .05;\n\n      if (scale > this.minScale && scale <= this._maxScale) {\n        this.setScale(scale);\n      } else {\n        this.setScale(this._maxScale);\n      }\n    }\n    /** Clean the img cropper */\n\n\n    clean() {\n      // fix choosing the same image does not load\n      if (this._currentInputElement) {\n        this._currentInputElement.value = '';\n        this._currentInputElement = null;\n      }\n\n      if (this.isLoaded) {\n        this._imgRect = {};\n        this.offset = undefined;\n        this.scale = undefined;\n        this._scal3Fix = undefined;\n        this._rotation = 0;\n        this._minScale = undefined;\n        this._isLoadedImg = false;\n        this.isLoaded = false;\n        this.isCropped = false;\n        this._currentLoadConfig = undefined;\n        this.config = this._configPrimary;\n        const canvas = this._imgCanvas.nativeElement;\n        canvas.width = 0;\n        canvas.height = 0;\n        this.cleaned.emit(null);\n        this.cd.markForCheck();\n      }\n    }\n    /** - */\n\n\n    zoomOut() {\n      const scale = this._scal3Fix - .05;\n\n      if (scale > this.minScale && scale <= this._maxScale) {\n        this.setScale(scale);\n      } else {\n        this.fit();\n      }\n    }\n\n    center() {\n      const newStyles = Object.assign({}, this._getCenterPoints());\n\n      this._setStylesForContImg(newStyles);\n\n      this._cropIfAutoCrop();\n    }\n    /**\n     * load an image from a given configuration,\n     * or from the result of a cropped image\n     */\n\n\n    loadImage(config, fn) {\n      this.clean();\n\n      const _config = this._currentLoadConfig = typeof config === 'string' ? {\n        originalDataURL: config\n      } : Object.assign({}, config);\n\n      let src = _config.originalDataURL;\n      this._primaryAreaWidth = this._configPrimary.width;\n      this._primaryAreaHeight = this._configPrimary.height;\n\n      if (_config.areaWidth && _config.areaHeight) {\n        this.config.width = _config.areaWidth;\n        this.config.height = _config.areaHeight;\n      }\n\n      src = normalizeSVG(src);\n      const img = createHtmlImg(src);\n      const cropEvent = Object.assign({}, _config);\n      new Observable(observer => {\n        img.onerror = err => observer.error(err);\n\n        img.onabort = err => observer.error(err);\n\n        img.onload = () => observer.next(null);\n      }).pipe(take(1), takeUntil(this._destroy)).subscribe(() => {\n        this._imgLoaded(img);\n\n        this._isLoadedImg = true;\n        this.imageLoaded.emit(cropEvent);\n        this.cd.markForCheck();\n\n        this._ngZone.runOutsideAngular(() => {\n          this._ngZone.onStable.asObservable().pipe(take(1), takeUntil(this._destroy)).subscribe(() => setTimeout(() => this._ngZone.run(() => this._positionImg(cropEvent, fn))));\n        });\n      }, () => {\n        const error = {\n          name: _config.name,\n          error: ImgCropperError.Type,\n          type: _config.type,\n          size: _config.size\n        };\n        this.error.emit(error);\n      });\n    }\n\n    _updateAreaIfNeeded() {\n      if (!this._config.responsiveArea) {\n        return;\n      }\n\n      const rootRect = this._rootRect();\n\n      const areaRect = this._areaCropperRect();\n\n      const minWidth = this.config.minWidth || 1;\n      const minHeight = this.config.minHeight || 1;\n\n      if (!(areaRect.width > rootRect.width || areaRect.height > rootRect.height || areaRect.width < this._primaryAreaWidth || areaRect.height < this._primaryAreaHeight)) {\n        return;\n      }\n\n      const areaWidthConf = Math.max(this.config.width, minWidth);\n      const areaWidthMax = Math.max(rootRect.width, minWidth);\n      const minHost = Math.min(Math.max(rootRect.width, minWidth), Math.max(rootRect.height, minHeight));\n      const currentScale = this._scal3Fix;\n      let newScale = 0;\n      const roundConf = this.config.round;\n\n      if (roundConf) {\n        this.config.width = this.config.height = minHost;\n      } else {\n        if (areaWidthConf === areaRect.width) {\n          if (areaWidthMax > this._primaryAreaWidth) {\n            this.config.width = this._primaryAreaWidth;\n            this.config.height = this._primaryAreaWidth * areaRect.height / areaRect.width;\n            newScale = currentScale * this._primaryAreaWidth / areaRect.width;\n          } else {\n            this.config.width = areaWidthMax;\n            this.config.height = areaWidthMax * areaRect.height / areaRect.width;\n            newScale = currentScale * areaWidthMax / areaRect.width;\n          }\n\n          this._updateMinScale();\n\n          this._updateMaxScale();\n\n          this.setScale(newScale, true);\n\n          this._markForCheck();\n        }\n      }\n    }\n\n    _updateAbsoluteScale() {\n      const scale = this._scal3Fix / (this.config.width / this._primaryAreaWidth);\n      this._absoluteScale = scale;\n    }\n    /**\n     * Load Image from URL\n     * @deprecated Use `loadImage` instead of `setImageUrl`\n     * @param src URL\n     * @param fn function that will be called before emit the event loaded\n     */\n\n\n    setImageUrl(src, fn) {\n      this.loadImage(src, fn);\n    }\n\n    _positionImg(cropEvent, fn) {\n      const loadConfig = this._currentLoadConfig;\n\n      this._updateMinScale(this._imgCanvas.nativeElement);\n\n      this._updateMaxScale();\n\n      this.isLoaded = false;\n\n      if (fn) {\n        fn();\n      } else {\n        if (loadConfig.scale) {\n          this.setScale(loadConfig.scale, true);\n        } else {\n          this.setScale(this.minScale, true);\n        }\n\n        this.rotate(loadConfig.rotation || 0);\n\n        this._updateAreaIfNeeded();\n\n        this._markForCheck();\n\n        this._ngZone.runOutsideAngular(() => {\n          this._ngZone.onStable.asObservable().pipe(take(1), takeUntil(this._destroy)).subscribe(() => {\n            if (loadConfig.xOrigin != null && loadConfig.yOrigin != null) {\n              this.updatePosition(loadConfig.xOrigin, loadConfig.yOrigin);\n            }\n\n            this._updateAreaIfNeeded();\n\n            this.isLoaded = true;\n\n            this._cropIfAutoCrop();\n\n            this._ngZone.run(() => {\n              this._markForCheck();\n\n              this.ready.emit(cropEvent); // tslint:disable-next-line: deprecation\n\n              this.loaded.emit(cropEvent);\n            });\n          });\n        });\n      }\n    }\n\n    rotate(degrees) {\n      let validDegrees = _normalizeDegrees(degrees); // If negative convert to positive\n\n\n      if (validDegrees < 0) {\n        validDegrees += 360;\n      }\n\n      const newRotation = _normalizeDegrees((this._rotation || 0) + validDegrees);\n\n      if (newRotation === this._rotation) {\n        return;\n      }\n\n      const degreesRad = validDegrees * Math.PI / 180;\n      const canvas = this._imgCanvas.nativeElement;\n      const canvasClon = createCanvasImg(canvas);\n      const ctx = canvas.getContext('2d');\n      this._rotation = newRotation; // clear\n\n      ctx.clearRect(0, 0, canvasClon.width, canvasClon.height); // rotate canvas image\n\n      const transform = `rotate(${validDegrees}deg) scale(${1 / this._scal3Fix})`;\n      const transformOrigin = `${this._imgRect.xc}px ${this._imgRect.yc}px 0`;\n      canvas.style.transform = transform; // tslint:disable-next-line: deprecation\n\n      canvas.style.webkitTransform = transform;\n      canvas.style.transformOrigin = transformOrigin; // tslint:disable-next-line: deprecation\n\n      canvas.style.webkitTransformOrigin = transformOrigin;\n      const {\n        left,\n        top\n      } = canvas.getBoundingClientRect(); // save rect\n\n      const canvasRect = canvas.getBoundingClientRect(); // remove rotate styles\n\n      canvas.removeAttribute('style'); // set w & h\n\n      const w = canvasRect.width;\n      const h = canvasRect.height;\n      ctx.canvas.width = w;\n      ctx.canvas.height = h; // clear\n\n      ctx.clearRect(0, 0, w, h); // translate and rotate\n\n      ctx.translate(w / 2, h / 2);\n      ctx.rotate(degreesRad);\n      ctx.drawImage(canvasClon, -canvasClon.width / 2, -canvasClon.height / 2); // Update min scale\n\n      this._updateMinScale(canvas);\n\n      this._updateMaxScale(); // set the minimum scale, only if necessary\n\n\n      if (this.scale < this.minScale) {\n        this.setScale(0, true);\n      } //                ↑ no AutoCrop\n\n\n      const rootRect = this._rootRect();\n\n      this._setStylesForContImg({\n        x: left - rootRect.left,\n        y: top - rootRect.top\n      }); // keep image inside the frame\n\n\n      const originPosition = Object.assign({}, this._imgRect);\n      this.offset = {\n        x: originPosition.x,\n        y: originPosition.y,\n        left: originPosition.xc,\n        top: originPosition.yc\n      };\n\n      this._setStylesForContImg({});\n\n      this._simulatePointerMove();\n\n      this._cropIfAutoCrop();\n    }\n\n    _updateMinScale(canvas) {\n      if (!canvas) {\n        canvas = this._imgCanvas.nativeElement;\n      }\n\n      const config = this.config;\n      const minScale = (config.extraZoomOut ? Math.min : Math.max)(config.width / canvas.width, config.height / canvas.height);\n      this._minScale = minScale;\n      this.minScaleChange.emit(minScale);\n    }\n\n    _updateMaxScale() {\n      const maxScale = this.config.width / this._primaryAreaWidth;\n      this._maxScale = maxScale;\n      this.maxScaleChange.emit(maxScale);\n    }\n    /**\n     * Resize & crop image\n     */\n\n\n    crop(config) {\n      const newConfig = config ? mergeDeep({}, this.config || new ImgCropperConfig(), config) : this.config;\n\n      const cropEvent = this._imgCrop(newConfig);\n\n      this.cd.markForCheck();\n      return cropEvent;\n    }\n    /**\n     * @docs-private\n     */\n\n\n    _imgCrop(myConfig) {\n      const canvasElement = document.createElement('canvas');\n\n      const areaRect = this._areaCropperRect();\n\n      const canvasRect = this._canvasRect();\n\n      const scaleFix = this._scal3Fix;\n      const left = (areaRect.left - canvasRect.left) / scaleFix;\n      const top = (areaRect.top - canvasRect.top) / scaleFix;\n      const {\n        output\n      } = myConfig;\n      const currentImageLoadConfig = this._currentLoadConfig;\n      const area = {\n        width: myConfig.width,\n        height: myConfig.height\n      };\n      canvasElement.width = area.width / scaleFix;\n      canvasElement.height = area.height / scaleFix;\n      const ctx = canvasElement.getContext('2d');\n\n      if (myConfig.fill) {\n        ctx.fillStyle = myConfig.fill;\n        ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);\n      }\n\n      ctx.drawImage(this._imgCanvas.nativeElement, -left, -top);\n      const result = canvasElement;\n\n      if (myConfig.output === ImgResolution.Default) {\n        resizeCanvas(result, this._configPrimary.width, this._configPrimary.height);\n      } else if (typeof output === 'object') {\n        if (output.width && output.height) {\n          resizeCanvas(result, output.width, output.height);\n        } else if (output.width) {\n          const newHeight = area.height * output.width / area.width;\n          resizeCanvas(result, output.width, newHeight);\n        } else if (output.height) {\n          const newWidth = area.width * output.height / area.height;\n          resizeCanvas(result, newWidth, output.height);\n        }\n      }\n\n      const type = currentImageLoadConfig.originalDataURL.startsWith('http') ? currentImageLoadConfig.type || myConfig.type : myConfig.type || currentImageLoadConfig.type;\n      const dataURL = result.toDataURL(type);\n      const cropEvent = {\n        dataURL,\n        type,\n        name: currentImageLoadConfig.name,\n        areaWidth: this._primaryAreaWidth,\n        areaHeight: this._primaryAreaHeight,\n        width: result.width,\n        height: result.height,\n        originalDataURL: currentImageLoadConfig.originalDataURL,\n        scale: this._absoluteScale,\n        rotation: this._rotation,\n        left: (areaRect.left - canvasRect.left) / this._scal3Fix,\n        top: (areaRect.top - canvasRect.top) / this._scal3Fix,\n        size: currentImageLoadConfig.size,\n        xOrigin: this._imgRect.xc,\n        yOrigin: this._imgRect.yc,\n        position: {\n          x: this._imgRect.xc,\n          y: this._imgRect.yc\n        }\n      };\n      this.isCropped = true;\n      this.cropped.emit(cropEvent);\n      return cropEvent;\n    }\n\n    _rootRect() {\n      return this._elementRef.nativeElement.getBoundingClientRect();\n    }\n\n    _areaCropperRect() {\n      return this._areaRef.nativeElement.getBoundingClientRect();\n    }\n\n    _canvasRect() {\n      return this._imgCanvas.nativeElement.getBoundingClientRect();\n    }\n\n    _bindGlobalEvents(triggerEvent) {\n      const element = this._document;\n      const isTouch = isTouchEvent(triggerEvent);\n      const moveEventName = isTouch ? 'touchmove' : 'mousemove';\n      const endEventName = isTouch ? 'touchend' : 'mouseup';\n      element.addEventListener(moveEventName, this._pointerMove, activeEventOptions);\n      element.addEventListener(endEventName, this._pointerUp, activeEventOptions);\n\n      if (isTouch) {\n        element.addEventListener('touchcancel', this._pointerUp, activeEventOptions);\n      }\n\n      const window = this._getWindow();\n\n      if (typeof window !== 'undefined' && window) {\n        window.addEventListener('blur', this._windowBlur);\n      }\n    }\n    /** Removes any global event listeners that we may have added. */\n\n\n    _removeGlobalEvents() {\n      const element = this._document;\n      element.removeEventListener('mousemove', this._pointerMove, activeEventOptions);\n      element.removeEventListener('mouseup', this._pointerUp, activeEventOptions);\n      element.removeEventListener('touchmove', this._pointerMove, activeEventOptions);\n      element.removeEventListener('touchend', this._pointerUp, activeEventOptions);\n      element.removeEventListener('touchcancel', this._pointerUp, activeEventOptions);\n\n      const window = this._getWindow();\n\n      if (typeof window !== 'undefined' && window) {\n        window.removeEventListener('blur', this._windowBlur);\n      }\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n\n\n    _getWindow() {\n      return this._document.defaultView || window;\n    }\n\n  }\n\n  LyImageCropper.и = 'LyImageCropper';\n\n  LyImageCropper.ɵfac = function LyImageCropper_Factory(t) {\n    return new (t || LyImageCropper)(i0.ɵɵdirectiveInject(i1.StyleRenderer), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i2.ViewportRuler));\n  };\n\n  LyImageCropper.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: LyImageCropper,\n    selectors: [[\"ly-img-cropper\"], [\"ly-image-cropper\"]],\n    viewQuery: function LyImageCropper_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n        i0.ɵɵviewQuery(_c1, 5, ElementRef);\n        i0.ɵɵviewQuery(_c2, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._imgContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._areaRef = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._imgCanvas = _t.first);\n      }\n    },\n    inputs: {\n      config: \"config\",\n      scale: \"scale\",\n      maxFileSize: \"maxFileSize\"\n    },\n    outputs: {\n      scaleChange: \"scaleChange\",\n      minScaleChange: \"minScale\",\n      maxScaleChange: \"maxScale\",\n      loaded: \"loaded\",\n      imageLoaded: \"imageLoaded\",\n      ready: \"ready\",\n      cropped: \"cropped\",\n      cleaned: \"cleaned\",\n      error: \"error\"\n    },\n    features: [i0.ɵɵProvidersFeature([StyleRenderer])],\n    ngContentSelectors: _c4,\n    decls: 7,\n    vars: 3,\n    consts: [[3, \"className\", \"selectstart\"], [\"_imgContainer\", \"\"], [\"_imgCanvas\", \"\"], [3, \"round\", \"resizableArea\", \"keepAspectRatio\", \"ngStyle\", 4, \"ngIf\", \"ngIfElse\"], [\"content\", \"\"], [3, \"round\", \"resizableArea\", \"keepAspectRatio\", \"ngStyle\"], [\"_area\", \"\"], [3, \"className\"], [\"type\", \"file\", \"accept\", \"image/*\", 3, \"change\"], [\"_fileInput\", \"\"]],\n    template: function LyImageCropper_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵlistener(\"selectstart\", function LyImageCropper_Template_div_selectstart_0_listener($event) {\n          return $event.preventDefault();\n        });\n        i0.ɵɵelement(2, \"canvas\", null, 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(4, LyImageCropper_ly_cropper_area_4_Template, 2, 7, \"ly-cropper-area\", 3);\n        i0.ɵɵtemplate(5, LyImageCropper_ng_template_5_Template, 4, 1, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r3 = i0.ɵɵreference(6);\n\n        i0.ɵɵproperty(\"className\", ctx.classes.imgContainer);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", ctx._isLoadedImg)(\"ngIfElse\", _r3);\n      }\n    },\n    dependencies: function () {\n      return [LyCropperArea, i3.NgIf, i3.NgStyle];\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return LyImageCropper;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @dynamic\n */\n\n\nlet LyCropperArea = /*#__PURE__*/(() => {\n  class LyCropperArea {\n    constructor(sRenderer, _elementRef, _ngZone, _cropper, _document) {\n      this.sRenderer = sRenderer;\n      this._elementRef = _elementRef;\n      this._ngZone = _ngZone;\n      this._cropper = _cropper;\n      this.classes = this.sRenderer.renderSheet(STYLES, 'area');\n\n      this._pointerDown = event => {\n        // Don't do anything if the\n        // user is using anything other than the main mouse button.\n        if (this._isSliding || !isTouchEvent(event) && event.button !== 0) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this._ngZone.run(() => {\n          this._isSliding = true;\n          this._lastPointerEvent = event;\n          this._startPointerEvent = getGesturePointFromEvent(event);\n          this._startAreaRect = this._cropper._areaCropperRect();\n          this._startImgRect = this._cropper._canvasRect();\n          event.preventDefault();\n\n          this._bindGlobalEvents(event);\n        });\n      };\n\n      this._pointerMove = event => {\n        if (this._isSliding) {\n          event.preventDefault();\n          this._lastPointerEvent = event;\n          const element = this._elementRef.nativeElement;\n          const {\n            width,\n            height,\n            minWidth,\n            minHeight\n          } = this._cropper.config;\n          const point = getGesturePointFromEvent(event);\n          const deltaX = point.x - this._startPointerEvent.x;\n          const deltaY = point.y - this._startPointerEvent.y;\n          const startAreaRect = this._startAreaRect;\n          const startImgRect = this._startImgRect;\n          const round = this.round;\n          const keepAspectRatio = this._cropper.config.keepAspectRatio || event.shiftKey;\n          let newWidth = 0;\n          let newHeight = 0;\n\n          const rootRect = this._cropper._rootRect();\n\n          if (round) {\n            // The distance from the center of the cropper area to the pointer\n            const originX = width / 2 / Math.sqrt(2) + deltaX;\n            const originY = height / 2 / Math.sqrt(2) + deltaY; // Leg\n\n            const side = Math.sqrt(Math.pow(originX, 2) + Math.pow(originY, 2));\n            newWidth = newHeight = side * 2;\n          } else if (keepAspectRatio) {\n            newWidth = width + deltaX * 2;\n            newHeight = height + deltaY * 2;\n\n            if (width !== height) {\n              if (width > height) {\n                newHeight = height / (width / newWidth);\n              } else if (height > width) {\n                newWidth = width / (height / newHeight);\n              }\n            } else {\n              newWidth = newHeight = Math.max(newWidth, newHeight);\n            }\n          } else {\n            newWidth = width + deltaX * 2;\n            newHeight = height + deltaY * 2;\n          } // To min width\n\n\n          if (newWidth < minWidth) {\n            newWidth = minWidth;\n          } // To min height\n\n\n          if (newHeight < minHeight) {\n            newHeight = minHeight;\n          } // Do not overflow the cropper area\n\n\n          const centerX = startAreaRect.x + startAreaRect.width / 2;\n          const centerY = startAreaRect.y + startAreaRect.height / 2;\n          const topOverflow = startImgRect.y > centerY - newHeight / 2;\n          const bottomOverflow = centerY + newHeight / 2 > startImgRect.bottom;\n          const minHeightOnOverflow = Math.min((centerY - startImgRect.y) * 2, (startImgRect.bottom - centerY) * 2);\n          const leftOverflow = startImgRect.x > centerX - newWidth / 2;\n          const rightOverflow = centerX + newWidth / 2 > startImgRect.right;\n          const minWidthOnOverflow = Math.min((centerX - startImgRect.x) * 2, (startImgRect.right - centerX) * 2);\n          const minOnOverflow = Math.min(minWidthOnOverflow, minHeightOnOverflow);\n\n          if (round) {\n            if (topOverflow || bottomOverflow || leftOverflow || rightOverflow) {\n              newHeight = newWidth = minOnOverflow;\n            }\n          } else if (keepAspectRatio) {\n            const newNewWidth = [];\n            const newNewHeight = [];\n\n            if (topOverflow || bottomOverflow) {\n              newHeight = minHeightOnOverflow;\n              newNewHeight.push(newHeight);\n              newWidth = width / (height / minHeightOnOverflow);\n              newNewWidth.push(newWidth);\n            }\n\n            if (leftOverflow || rightOverflow) {\n              newWidth = minWidthOnOverflow;\n              newNewWidth.push(newWidth);\n              newHeight = height / (width / minWidthOnOverflow);\n              newNewHeight.push(newHeight);\n            }\n\n            if (newNewWidth.length === 2) {\n              newWidth = Math.min(...newNewWidth);\n            }\n\n            if (newNewHeight.length === 2) {\n              newHeight = Math.min(...newNewHeight);\n            }\n          } else {\n            if (topOverflow || bottomOverflow) {\n              newHeight = minHeightOnOverflow;\n            }\n\n            if (leftOverflow || rightOverflow) {\n              newWidth = minWidthOnOverflow;\n            }\n          } // Do not overflow the container\n\n\n          if (round) {\n            const min = Math.min(rootRect.width, rootRect.height);\n\n            if (newWidth > min) {\n              newWidth = newHeight = min;\n            } else if (newHeight > min) {\n              newWidth = newHeight = min;\n            }\n          } else if (keepAspectRatio) {\n            if (newWidth > rootRect.width) {\n              newWidth = rootRect.width;\n              newHeight = height / (width / rootRect.width);\n            }\n\n            if (newHeight > rootRect.height) {\n              newWidth = width / (height / rootRect.height);\n              newHeight = rootRect.height;\n            }\n          } else {\n            if (newWidth > rootRect.width) {\n              newWidth = rootRect.width;\n            }\n\n            if (newHeight > rootRect.height) {\n              newHeight = rootRect.height;\n            }\n          } // round values\n\n\n          newWidth = Math.round(newWidth);\n          newHeight = Math.round(newHeight);\n          element.style.width = `${newWidth}px`;\n          element.style.height = `${newHeight}px`;\n          this._currentWidth = newWidth;\n          this._currentHeight = newHeight;\n        }\n      };\n      /** Called when the user has lifted their pointer. */\n\n\n      this._pointerUp = event => {\n        if (this._isSliding) {\n          event.preventDefault();\n\n          this._removeGlobalEvents();\n\n          this._cropper._primaryAreaWidth = this._cropper.config.width = this._currentWidth;\n          this._cropper._primaryAreaHeight = this._cropper.config.height = this._currentHeight;\n          this._cropper.config = this._cropper.config;\n\n          this._cropper._updateMinScale();\n\n          this._isSliding = false;\n          this._startPointerEvent = null;\n        }\n      };\n      /** Called when the window has lost focus. */\n\n\n      this._windowBlur = () => {\n        // If the window is blurred while dragging we need to stop dragging because the\n        // browser won't dispatch the `mouseup` and `touchend` events anymore.\n        if (this._lastPointerEvent) {\n          this._pointerUp(this._lastPointerEvent);\n        }\n      };\n\n      this._document = _document;\n    }\n\n    set resizableArea(val) {\n      if (val !== this._resizableArea) {\n        this._resizableArea = val;\n        Promise.resolve(null).then(() => {\n          if (val) {\n            this._removeResizableArea();\n\n            this._addResizableArea();\n          } else {\n            this._removeResizableArea();\n          }\n        });\n      }\n    }\n\n    get resizableArea() {\n      return this._resizableArea;\n    }\n\n    ngOnDestroy() {\n      this._removeResizableArea();\n    }\n\n    _addResizableArea() {\n      this._ngZone.runOutsideAngular(() => {\n        const element = this._resizer.nativeElement;\n        element.addEventListener('mousedown', this._pointerDown, activeEventOptions);\n        element.addEventListener('touchstart', this._pointerDown, activeEventOptions);\n      });\n    }\n\n    _removeResizableArea() {\n      var _a;\n\n      const element = (_a = this._resizer) === null || _a === void 0 ? void 0 : _a.nativeElement;\n\n      if (element) {\n        this._lastPointerEvent = null;\n\n        this._removeGlobalEvents();\n\n        element.removeEventListener('mousedown', this._pointerDown, activeEventOptions);\n        element.removeEventListener('touchstart', this._pointerDown, activeEventOptions);\n      }\n    }\n\n    _bindGlobalEvents(triggerEvent) {\n      const element = this._document;\n      const isTouch = isTouchEvent(triggerEvent);\n      const moveEventName = isTouch ? 'touchmove' : 'mousemove';\n      const endEventName = isTouch ? 'touchend' : 'mouseup';\n      element.addEventListener(moveEventName, this._pointerMove, activeEventOptions);\n      element.addEventListener(endEventName, this._pointerUp, activeEventOptions);\n\n      if (isTouch) {\n        element.addEventListener('touchcancel', this._pointerUp, activeEventOptions);\n      }\n\n      const window = this._getWindow();\n\n      if (typeof window !== 'undefined' && window) {\n        window.addEventListener('blur', this._windowBlur);\n      }\n    }\n    /** Removes any global event listeners that we may have added. */\n\n\n    _removeGlobalEvents() {\n      const element = this._document;\n      element.removeEventListener('mousemove', this._pointerMove, activeEventOptions);\n      element.removeEventListener('mouseup', this._pointerUp, activeEventOptions);\n      element.removeEventListener('touchmove', this._pointerMove, activeEventOptions);\n      element.removeEventListener('touchend', this._pointerUp, activeEventOptions);\n      element.removeEventListener('touchcancel', this._pointerUp, activeEventOptions);\n\n      const window = this._getWindow();\n\n      if (typeof window !== 'undefined' && window) {\n        window.removeEventListener('blur', this._windowBlur);\n      }\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n\n\n    _getWindow() {\n      return this._document.defaultView || window;\n    }\n\n  }\n\n  LyCropperArea.ɵfac = function LyCropperArea_Factory(t) {\n    return new (t || LyCropperArea)(i0.ɵɵdirectiveInject(i1.StyleRenderer), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(LyImageCropper), i0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  LyCropperArea.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: LyCropperArea,\n    selectors: [[\"ly-cropper-area\"]],\n    viewQuery: function LyCropperArea_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c5, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._resizer = _t.first);\n      }\n    },\n    inputs: {\n      resizableArea: \"resizableArea\",\n      keepAspectRatio: \"keepAspectRatio\",\n      round: \"round\"\n    },\n    exportAs: [\"lyCropperArea\"],\n    features: [i0.ɵɵProvidersFeature([StyleRenderer])],\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"class\", 4, \"ngIf\"], [\"resizer\", \"\"]],\n    template: function LyCropperArea_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, LyCropperArea_div_0_Template, 2, 2, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.resizableArea);\n      }\n    },\n    dependencies: [i3.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([Style2((_value, _media) => ({\n    after\n  }, ref) => {\n    ref.renderStyleSheet(STYLES);\n\n    const __ = ref.selectorsOf(STYLES);\n\n    return _className => `${_className}{border-radius:50%;}${_className} .${__.resizer}{${after}:${pos}%;bottom:${pos}%;transform:translate(4px,4px);}`;\n  }, coerceBooleanProperty)], LyCropperArea.prototype, \"round\", void 0);\n\n  return LyCropperArea;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Normalize degrees for cropper rotation\n * @docs-private\n */\n\n\nfunction _normalizeDegrees(n) {\n  const de = n % 360;\n\n  if (de % 90) {\n    throw new Error(`LyCropper: Invalid \\`${n}\\` degree, only accepted values: 0, 90, 180, 270 & 360.`);\n  }\n\n  return de;\n}\n/**\n * @docs-private\n */\n\n\nfunction createCanvasImg(img) {\n  // create a new canvas\n  const newCanvas = document.createElement('canvas');\n  const context = newCanvas.getContext('2d'); // set dimensions\n\n  newCanvas.width = img.width;\n  newCanvas.height = img.height; // apply the old canvas to the new one\n\n  context.drawImage(img, 0, 0); // return the new canvas\n\n  return newCanvas;\n}\n\nfunction normalizeSVG(dataURL) {\n  if (window.atob && isSvgImage(dataURL)) {\n    const len = dataURL.length / 5;\n    const text = window.atob(dataURL.replace(DATA_IMAGE_SVG_PREFIX, ''));\n    const span = document.createElement('span');\n    span.innerHTML = text;\n    const svg = span.querySelector('svg');\n    span.setAttribute('style', 'display:none');\n    document.body.appendChild(span);\n    const width = parseFloat(getComputedStyle(svg).width) || 1;\n    const height = parseFloat(getComputedStyle(svg).height) || 1;\n    const max = Math.max(width, height);\n    svg.setAttribute('width', `${len / (width / max)}px`);\n    svg.setAttribute('height', `${len / (height / max)}px`);\n    const result = DATA_IMAGE_SVG_PREFIX + window.btoa(span.innerHTML);\n    document.body.removeChild(span);\n    return result;\n  }\n\n  return dataURL;\n}\n\nfunction isSvgImage(dataUrl) {\n  return dataUrl.startsWith(DATA_IMAGE_SVG_PREFIX);\n}\n\nfunction createHtmlImg(src) {\n  const img = new Image();\n  img.crossOrigin = 'anonymous';\n  img.src = src;\n  return img;\n}\n\nfunction getGesturePointFromEvent(event) {\n  // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;\n  return {\n    x: point.clientX,\n    y: point.clientY\n  };\n}\n/** Returns whether an event is a touch event. */\n\n\nfunction isTouchEvent(event) {\n  return event.type[0] === 't';\n}\n\nfunction roundNumber(n) {\n  return Math.round(n);\n}\n\nlet LyImageCropperModule = /*#__PURE__*/(() => {\n  class LyImageCropperModule {}\n\n  LyImageCropperModule.ɵfac = function LyImageCropperModule_Factory(t) {\n    return new (t || LyImageCropperModule)();\n  };\n\n  LyImageCropperModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LyImageCropperModule\n  });\n  LyImageCropperModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return LyImageCropperModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ImgCropperConfig, ImgCropperError, ImgResolution, LyCropperArea, LyImageCropper, LyImageCropperModule, STYLES, _normalizeDegrees, roundNumber }; //# sourceMappingURL=alyle-ui-image-cropper.mjs.map","map":null,"metadata":{},"sourceType":"module"}