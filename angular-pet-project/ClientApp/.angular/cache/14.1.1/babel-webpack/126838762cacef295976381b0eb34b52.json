{"ast":null,"code":"import { Color, hexColorToInt } from '@alyle/ui/color';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Input, NgModule, ElementRef, isDevMode, ViewEncapsulation, Injectable, Inject, Optional, Component, HostListener, Injector, TemplateRef, ChangeDetectionStrategy } from '@angular/core';\nimport * as i1 from '@angular/cdk/platform';\nimport { DOCUMENT } from '@angular/common';\nimport { Subject, ReplaySubject, Subscription, merge, fromEvent, empty } from 'rxjs';\nimport { __decorate } from 'tslib';\nimport { coerceNumberProperty } from '@angular/cdk/coercion';\nimport { takeUntil, auditTime, map, share } from 'rxjs/operators';\nimport { HammerGestureConfig } from '@angular/platform-browser';\nimport * as i2 from '@angular/cdk/scrolling';\n\nfunction getContrastYIQ(hexcolor) {\n  const r = parseInt(hexcolor.substr(0, 2), 16);\n  const g = parseInt(hexcolor.substr(2, 2), 16);\n  const b = parseInt(hexcolor.substr(4, 2), 16);\n  const yiq = (r * 299 + g * 587 + b * 114) / 1000;\n  return yiq >= 128 ? 'black' : 'white';\n}\n\nconst shadowKeyUmbraOpacity = 0.2;\nconst shadowKeyPenumbraOpacity = 0.14;\nconst shadowAmbientShadowOpacity = 0.12;\nconst Shadows = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 3, 0, 0, 1, 1, 0, 0, 2, 1, -1], [0, 1, 5, 0, 0, 2, 2, 0, 0, 3, 1, -2], [0, 1, 8, 0, 0, 3, 4, 0, 0, 3, 3, -2], [0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0], [0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0], [0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0], [0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1], [0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2], [0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2], [0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3], [0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3], [0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4], [0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4], [0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4], [0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5], [0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5], [0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5], [0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6], [0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6], [0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7], [0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7], [0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7], [0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8], [0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8]];\n\nfunction shadowBuilder(elevation, color) {\n  let _color = color || new Color(0, 0, 0);\n\n  const rgb = _color.rgba();\n\n  if (!(rgb[0] === rgb[1] && rgb[0] === rgb[2])) {\n    // Darken and saturate if the color is not in the grayscale\n    _color = _color.darken().saturate(2);\n  }\n\n  const colors = [_color.alpha(shadowKeyUmbraOpacity).css(), _color.alpha(shadowKeyPenumbraOpacity).css(), _color.alpha(shadowAmbientShadowOpacity).css()];\n  const e = Shadows[elevation]; // tslint:disable-next-line:max-line-length\n\n  return `${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px ${colors[0]},${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px ${colors[1]},${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px ${colors[2]}`;\n}\n\nconst THEME_VARIABLES = new InjectionToken('ly.theme.variables');\nconst IS_CORE_THEME = new InjectionToken('ly.is.root'); // Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\n\nconst hasV8BreakIterator = typeof Intl !== 'undefined' && Intl.v8BreakIterator;\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n * @deprecated Use Angular CDK instead\n * `import { Platform } from '@angular/cdk/platform'`\n */\n\nclass Platform {}\n\nPlatform.isBrowser = typeof document === 'object' && !!document;\n/** Layout Engines */\n\nPlatform.EDGE = Platform.isBrowser && /(edge)/i.test(navigator.userAgent);\nPlatform.TRIDENT = Platform.isBrowser && /(msie|trident)/i.test(navigator.userAgent); // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n\nPlatform.BLINK = Platform.isBrowser && !!(window.chrome || hasV8BreakIterator) && !!CSS && !Platform.EDGE && !Platform.TRIDENT; // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n// ensure that Webkit runs standalone and is not used as another engine's base.\n\nPlatform.WEBKIT = Platform.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !Platform.BLINK && !Platform.EDGE && !Platform.TRIDENT;\n/** Browsers and Platform Types */\n\nPlatform.IOS = Platform.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n// them self as Gecko-like browsers and modify the userAgent's according to that.\n// Since we only cover one explicit Firefox case, we can simply check for Firefox\n// instead of having an unstable check for Gecko.\n\nPlatform.FIREFOX = Platform.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent); // Trident on mobile adds the android platform to the userAgent to trick detections.\n\nPlatform.ANDROID = Platform.isBrowser && /android/i.test(navigator.userAgent) && !Platform.TRIDENT; // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n// this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n// Safari browser should also use Webkit as its layout engine.\n\nPlatform.SAFARI = Platform.isBrowser && /safari/i.test(navigator.userAgent) && Platform.WEBKIT;\nlet supportsPassive;\n\nfunction supportsPassiveEventListeners() {\n  if (supportsPassive === void 0) {\n    try {\n      const opts = Object.defineProperty({}, 'passive', {\n        get: () => {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener('testPassive', null, opts);\n      window.removeEventListener('testPassive', null, opts);\n    } catch (e) {}\n  }\n\n  return supportsPassive;\n}\n\nlet NgTranscludeDirective = /*#__PURE__*/(() => {\n  class NgTranscludeDirective {\n    constructor(vcr, _platform) {\n      this.vcr = vcr;\n      this._platform = _platform;\n    }\n\n    set ngTransclude(templateRef) {\n      if (templateRef && !this._ngTransclude) {\n        if (this._platform.isBrowser && this._timeoutId != null) {\n          window.clearTimeout(this._timeoutId);\n          this._timeoutId = null;\n          this.vcr.clear();\n        }\n\n        this._ngTransclude = templateRef;\n        this.vcr.createEmbeddedView(templateRef);\n      } else if (this._ngTransclude && !templateRef) {\n        this._ngTransclude = null;\n        this.clear();\n      }\n    }\n\n    get getNgTransclude() {\n      return this._ngTransclude;\n    }\n\n    clear() {\n      if (this._platform.isBrowser && this.timeout) {\n        this._timeoutId = window.setTimeout(() => {\n          this.vcr.clear();\n          this._timeoutId = null;\n        }, this.timeout);\n      } else {\n        this.vcr.clear();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this._platform.isBrowser) {\n        window.clearTimeout(this._timeoutId);\n      }\n\n      this.vcr.clear();\n    }\n\n  }\n\n  NgTranscludeDirective.ɵfac = function NgTranscludeDirective_Factory(t) {\n    return new (t || NgTranscludeDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i1.Platform));\n  };\n\n  NgTranscludeDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgTranscludeDirective,\n    selectors: [[\"\", \"ngTransclude\", \"\"]],\n    inputs: {\n      timeout: \"timeout\",\n      ngTransclude: \"ngTransclude\"\n    },\n    exportAs: [\"ngTransclude\"]\n  });\n  return NgTranscludeDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgTranscludeModule = /*#__PURE__*/(() => {\n  class NgTranscludeModule {}\n\n  NgTranscludeModule.ɵfac = function NgTranscludeModule_Factory(t) {\n    return new (t || NgTranscludeModule)();\n  };\n\n  NgTranscludeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgTranscludeModule\n  });\n  NgTranscludeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgTranscludeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @ignore\n */\n\n\nfunction getNativeElement(element) {\n  return element instanceof ElementRef ? element.nativeElement : element;\n}\n\nconst DEFAULT_VALUE = '';\nconst STYLE_PRIORITY$2 = -1;\n\nfunction mixinStyleUpdater(base) {\n  return class extends base {\n    constructor(...args) {\n      super(...args);\n    }\n\n    setAutoContrast() {\n      this._autoContrast = true;\n    }\n\n    updateStyle(element) {\n      const __bg = this._superHyperInternalPropertyBg;\n\n      const __color = this._superHyperInternalPropertyColor === 'auto' ? '' : this._superHyperInternalPropertyColor;\n\n      const __raised = this._superHyperInternalPropertyRaised;\n      const __elevation = this._superHyperInternalPropertyElevation;\n      const __disabled = this._superHyperInternalPropertyDisabled;\n      const __outlined = this._superHyperInternalPropertyOutlined;\n      const __shadowColor = this._superHyperInternalPropertyShadowColor;\n\n      const __isContrast = this._autoContrast || this._superHyperInternalPropertyColor === 'auto';\n\n      const el = getNativeElement(element);\n      const newKey = `c--${__bg || DEFAULT_VALUE}_${__color || DEFAULT_VALUE}_${__raised || DEFAULT_VALUE}_${__elevation || DEFAULT_VALUE}_${__disabled || DEFAULT_VALUE}_${__outlined || DEFAULT_VALUE}_${__shadowColor || DEFAULT_VALUE}_${__isContrast || DEFAULT_VALUE}`;\n\n      const newClass = this._theme.renderStyle(newKey, theme => {\n        let sColor;\n        let sBackground;\n        let sBorder;\n        let sPointerEvents;\n        let sBoxShadow;\n        let sBoxShadowActive;\n\n        if (__outlined) {\n          sBorder = '1px solid currentColor';\n        }\n\n        if (__disabled) {\n          sColor = theme.disabled.contrast;\n          sPointerEvents = 'none';\n\n          if (__bg || __raised) {\n            sBackground = theme.disabled.default;\n          }\n        } else {\n          if (__bg) {\n            sBackground = colorOf(theme, __bg);\n\n            if (__isContrast && !__color) {\n              sColor = theme.colorOf(`${__bg}:contrast`); // Generate auto contrast if is necessary\n\n              if (sColor.css().includes('invalid')) {\n                const lum = (__bg instanceof Color ? __bg : theme.colorOf(__bg)).luminance();\n                sColor = lum < 0.5 ? theme.text.light : theme.text.dark;\n              }\n            }\n          }\n\n          if (!sColor && __color) {\n            sColor = colorOf(theme, __color);\n          }\n\n          if (__raised || __elevation != null) {\n            if (!__bg) {\n              sBackground = theme.background.primary.default;\n            }\n\n            const backgroundColorCss = sBackground !== __bg && colorOf(theme, __bg || 'background:primary', 'shadow');\n            const shadowColor = __shadowColor && colorOf(theme, __shadowColor) || backgroundColorCss || sBackground || sColor || theme.shadow;\n\n            if (__elevation != null) {\n              sBoxShadow = shadowBuilder(__elevation, shadowColor);\n            } else {\n              sBoxShadow = shadowBuilder(3, shadowColor);\n              sBoxShadowActive = shadowBuilder(8, shadowColor);\n            }\n          }\n        }\n\n        return _className => `${_className}{${sColor ? 'color:' + sColor : ''};${sBackground ? 'background:' + sBackground : ''};${sBorder ? 'border:' + sBorder : ''};${sPointerEvents ? 'pointer-events:' + sPointerEvents : ''};${sBoxShadow ? 'box-shadow:' + sBoxShadow : ''};}${_className}:active{${sBoxShadowActive ? 'box-shadow:' + sBoxShadowActive : ''};}`;\n      }, STYLE_PRIORITY$2);\n\n      el.classList.remove(this._classNameAnonymous);\n      el.classList.add(newClass);\n      this._classNameAnonymous = newClass;\n    }\n\n  };\n}\n\nfunction colorOf(theme, color, optional) {\n  return color instanceof Color ? color : theme.colorOf(color, optional);\n}\n\nfunction toBoolean(value) {\n  return value != null && `${value}` !== 'false';\n}\n\nclass RippleRef {\n  constructor() {\n    this.state = true;\n    this.timestamp = -Date.now();\n    this.container = document.createElement('span');\n  }\n\n  end() {\n    this.state = false;\n    this.timestamp += Date.now();\n  }\n\n}\n\nclass Ripple {\n  constructor(_themeVariables, _ngZone, classes, _containerElement, platform, _triggerElement) {\n    this._themeVariables = _themeVariables;\n    this._ngZone = _ngZone;\n    this.classes = classes;\n    this._containerElement = _containerElement;\n    this._triggerElement = _triggerElement;\n    this._eventHandlers = new Map();\n    this.config = {};\n    this._transitionDuration = this._themeVariables.ripple.duration;\n    this._eventOptions = {\n      passive: true\n    };\n\n    if (platform.isBrowser) {\n      if (typeof PointerEvent === 'function' && typeof TouchEvent === 'function') {\n        this._eventHandlers.set('pointerdown', this.onPointerDown.bind(this));\n      } else {\n        this._eventHandlers.set('mousedown', this.onPointerDown.bind(this));\n      }\n\n      this._eventHandlers.set('touchend', this.onPointerLeave.bind(this));\n\n      this._eventHandlers.set('touchcancel', this.onPointerLeave.bind(this));\n\n      this._eventHandlers.set('mouseup', this.onPointerLeave.bind(this));\n\n      this._eventHandlers.set('mouseleave', this.onPointerLeave.bind(this));\n\n      if (!_triggerElement) {\n        _triggerElement = _containerElement;\n      }\n\n      this.setTriggerElement(_triggerElement);\n    }\n  }\n\n  setConfig(config) {\n    this.config = config;\n  }\n\n  get _rectContainer() {\n    return this._containerElement.getBoundingClientRect();\n  }\n\n  setTriggerElement(element) {\n    if (element) {\n      this._ngZone.runOutsideAngular(() => {\n        this._eventHandlers.forEach((fn, type) => element.addEventListener(type, fn, this._eventOptions));\n      });\n    }\n\n    this._triggerElement = element;\n  }\n\n  createRipple(styles) {\n    this._rippleRef = new RippleRef();\n    const container = this._rippleRef.container;\n    container.className = this.classes.rippleContainer;\n\n    for (const key in styles) {\n      if (styles.hasOwnProperty(key)) {\n        const element = styles[key];\n\n        if (typeof element === 'number') {\n          container.style[key] = `${element}px`;\n        } else {\n          container.style[key] = element;\n        }\n      }\n    }\n\n    this._containerElement.appendChild(container);\n\n    window.getComputedStyle(container).getPropertyValue('opacity');\n    container.style.transform = `scale(1)`;\n  }\n\n  onPointerDown(event) {\n    if (!this.config.disabled) {\n      /**Destroy previous ripple if exist */\n      this.endRipple();\n      this.startRipple(event, this.config);\n    }\n  }\n\n  onPointerLeave(_event) {\n    if (!this.config.disabled) {\n      this.endRipple();\n    }\n  }\n\n  startRipple(event, rippleConfig) {\n    const containerRect = this._rectContainer;\n    let x = event.clientX,\n        y = event.clientY;\n\n    if (rippleConfig.centered) {\n      x = containerRect.left + containerRect.width / 2;\n      y = containerRect.top + containerRect.height / 2;\n    }\n\n    const left = x - containerRect.left;\n    const top = y - containerRect.top;\n    let radius = rippleConfig.radius === 'containerSize' ? maxSize(containerRect) / 2 : rippleConfig.radius || rippleRadius(x, y, containerRect);\n\n    if (rippleConfig.percentageToIncrease) {\n      radius += radius * rippleConfig.percentageToIncrease / 100;\n    }\n\n    this.createRipple({\n      left: left - radius,\n      top: top - radius,\n      width: radius * 2,\n      height: radius * 2,\n      transitionDuration: `${this._transitionDuration}ms`\n    });\n  }\n\n  runTimeoutOutsideZone(fn, delay = 0) {\n    this._ngZone.runOutsideAngular(() => setTimeout(fn, delay));\n  }\n\n  endRipple() {\n    const rippleRef = this._rippleRef;\n    const duration = this._transitionDuration;\n\n    if (rippleRef && rippleRef.state) {\n      rippleRef.end();\n      this.runTimeoutOutsideZone(() => {\n        rippleRef.container.style.opacity = '0';\n        rippleRef.container.style.transitionDuration = `${this._transitionDuration / 5}ms`; // }, rippleRef.timestamp < duration ? duration : 0);\n        // }, rippleRef.timestamp < duration ? duration / (duration * .001 + 1) : 0);\n      }, rippleRef.timestamp < duration ? duration * .15 : 0);\n      this.runTimeoutOutsideZone(() => {\n        rippleRef.container.parentNode.removeChild(rippleRef.container); // }, rippleRef.timestamp < duration ? duration * 2 : duration);\n        // }, rippleRef.timestamp < duration ? duration / (duration * .001 + 1) * 2 : duration);\n      }, rippleRef.timestamp < duration ? duration * 2 : duration);\n      this._rippleRef = undefined;\n    }\n  }\n\n  removeEvents() {\n    if (this._triggerElement) {\n      this._eventHandlers.forEach((fn, type) => {\n        this._triggerElement.removeEventListener(type, fn, this._eventOptions);\n      });\n    }\n  }\n\n}\n\nfunction rippleRadius(x, y, rect) {\n  const distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));\n  const distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));\n  return Math.sqrt(distX * distX + distY * distY);\n}\n\nfunction maxSize(rect) {\n  return Math.max(rect.width, rect.height);\n}\n\nconst LY_THEME_GLOBAL_VARIABLES = new InjectionToken('ly.theme.global.variables');\nconst LY_THEME = new InjectionToken('ly_theme_config');\nconst LY_THEME_NAME = new InjectionToken('ly.theme.name');\n/**\n * Add a prefix to the class name that will be generated for styles.\n * Only works in production mode.\n */\n\nconst LY_CLASS_NAME_PREFIX = new InjectionToken('LY_CLASS_NAME_PREFIX');\n\nfunction memoize(fn) {\n  const cache = {};\n  return key => {\n    if (cache[key] === undefined) {\n      cache[key] = fn(key);\n    }\n\n    return cache[key];\n  };\n}\n/**\n * For internal use only\n * @docsPrivate\n */\n\n\nconst _STYLE_MAP = new Map();\n\nvar TypeStyle = /*#__PURE__*/(() => {\n  (function (TypeStyle) {\n    TypeStyle[TypeStyle[\"Multiple\"] = 0] = \"Multiple\";\n    TypeStyle[TypeStyle[\"OnlyOne\"] = 1] = \"OnlyOne\";\n    /**\n     * A lyl Style\n     */\n\n    TypeStyle[TypeStyle[\"LylStyle\"] = 2] = \"LylStyle\";\n  })(TypeStyle || (TypeStyle = {}));\n\n  return TypeStyle;\n})();\nconst getThemeNameForSelectors = memoize(themeId => {\n  return `${themeId}<~(selectors)`;\n});\n\nconst LINE_FEED_REGEX = () => /[\\n\\s]*([^\\n]+)/g;\n\nconst AMPERSAND_REGEX = () => /&/g;\n\nvar RuleType = /*#__PURE__*/(() => {\n  (function (RuleType) {\n    RuleType[RuleType[\"FontFace\"] = 0] = \"FontFace\";\n    RuleType[RuleType[\"MediaQuery\"] = 1] = \"MediaQuery\";\n    RuleType[RuleType[\"KeyFrame\"] = 2] = \"KeyFrame\";\n    RuleType[RuleType[\"Style\"] = 3] = \"Style\";\n    RuleType[RuleType[\"DynamicStyle\"] = 4] = \"DynamicStyle\";\n    RuleType[RuleType[\"CompiledStyle\"] = 5] = \"CompiledStyle\";\n  })(RuleType || (RuleType = {}));\n\n  return RuleType;\n})();\n\n/**\n * Transform a lyl style block to CSS\n */\nclass LylParse {\n  constructor(_template, _className = '${_className}', _isServer,\n  /** Is true when used inside lyl */\n  _isDevMode) {\n    this._template = _template;\n    this._className = _className;\n    this._isServer = _isServer;\n    this._isDevMode = _isDevMode;\n  }\n\n  toCss() {\n    const selectors = [];\n    const resolvedSelectors = [];\n    const rules = [];\n\n    this._template.replace(/(\\/\\/\\s[^\\n\\r]*(?:[\\n\\r]+|$))/g, '') // remove comments\n    .replace(/,[\\n\\s]+/g, ',').replace(LINE_FEED_REGEX(), (_ex, fullLine) => {\n      if (fullLine.endsWith('{')) {\n        if (selectors.length === 0) {\n          selectors.push([this._className]);\n\n          this._createRule(rules, RuleType.Style, selectors, resolvedSelectors);\n        } else {\n          const line_1 = fullLine.slice(0, fullLine.length - 1).trim();\n\n          if (line_1 === '@font-face') {\n            selectors.push(line_1);\n\n            this._createRule(rules, RuleType.FontFace, selectors, resolvedSelectors);\n          } else if (line_1.startsWith('@m')) {\n            selectors.push(line_1);\n\n            this._createRule(rules, RuleType.MediaQuery, selectors, resolvedSelectors);\n          } else if (line_1.startsWith('@k')) {\n            selectors.push(line_1);\n\n            this._createRule(rules, RuleType.KeyFrame, selectors, resolvedSelectors);\n          } else {\n            selectors.push(line_1.split(',').map(_ => _.trim()));\n\n            this._createRule(rules, RuleType.Style, selectors, resolvedSelectors);\n          }\n        }\n      } else if (fullLine.length === 1 && fullLine === '}') {\n        this._removeParentSelector(rules, selectors, resolvedSelectors);\n      } else if (this._isDevMode && fullLine.startsWith('/* >> ds')) {\n        const lin = fullLine;\n\n        this._createRuleWithResolvedSelector(rules, RuleType.DynamicStyle, selectors, resolvedSelectors, lin);\n      } else if (this._isServer && fullLine.startsWith('...')) {\n        const content = fullLine.slice(3);\n\n        this._createRuleWithResolvedSelector(rules, RuleType.CompiledStyle, selectors, resolvedSelectors, content);\n      } else {\n        if (fullLine) {\n          if (this._isDevMode && fullLine.includes('undefined')) {\n            return '';\n          }\n\n          if (this._isDevMode && fullLine.endsWith(';')) {\n            throw new Error(`Do not require semicolon in [${fullLine}]`);\n          }\n\n          if (fullLine.includes(': ')) {\n            fullLine = fullLine.replace(': ', ':');\n          }\n\n          fullLine += ';';\n\n          this._appendDeclaration(rules, RuleType.Style, fullLine);\n        }\n      }\n\n      return '';\n    });\n\n    return rules.filter(rule => !rule.isEmpty).map(rule => {\n      return rule.block;\n    }).join('');\n  }\n\n  _createRule(rules, type, selectors, resolvedSelectors) {\n    const parentRule = resolvedSelectors[resolvedSelectors.length - 1];\n    const prevRule = rules[rules.length - 1];\n\n    if (prevRule && !prevRule.isReady) {\n      prevRule.block += `}`;\n      prevRule.isReady = true;\n    }\n\n    let selector = '';\n\n    if (type === RuleType.FontFace) {\n      selector = `@font-face`;\n    } else if (type === RuleType.KeyFrame) {\n      selector = selectors[1];\n    } else if (parentRule && parentRule.type === RuleType.KeyFrame) {\n      selector = selectors[selectors.length - 1][0];\n    } else if (type === RuleType.MediaQuery || parentRule && parentRule.type === RuleType.MediaQuery && prevRule && prevRule.isEmpty) {\n      selector = resolveSelectors(selectors, false);\n    } else {\n      selector = resolveSelectors(selectors, true);\n    }\n\n    const rule = {\n      selector,\n      block: `${selector}{`,\n      type: RuleType.Style,\n      isEmpty: true\n    };\n    resolvedSelectors.push({\n      selector: '',\n      block: '',\n      type: type,\n      isEmpty: true\n    });\n    rules.push(rule); // If is new media query\n\n    if (type === RuleType.MediaQuery) {\n      // rule.block += `{`;\n      rule.hasMedia = true;\n    }\n\n    if (parentRule && parentRule.hasMedia) {\n      rule.hasMedia = true;\n    }\n\n    if (type === RuleType.KeyFrame) {\n      rule.isReady = true;\n      rule.isEmpty = false;\n    }\n\n    return rule;\n  }\n\n  _createRuleWithResolvedSelector(rules, type, selectors, resolvedSelectors, content) {\n    if (!content) {\n      return;\n    }\n\n    const prevRule = rules[rules.length - 1];\n    const parentRule = resolvedSelectors[resolvedSelectors.length - 1];\n    const {\n      hasMedia\n    } = prevRule;\n    let selector = '';\n\n    if (type === RuleType.MediaQuery || parentRule && parentRule.type === RuleType.MediaQuery && prevRule && prevRule.isEmpty) {\n      selector = resolveSelectors(selectors, false);\n    } else {\n      selector = resolveSelectors(selectors, true);\n    } // Close previous\n\n\n    if (prevRule && !prevRule.isReady) {\n      prevRule.block += `}`;\n    }\n\n    const rule = {\n      selector: selector,\n      block: ``,\n      type,\n      hasMedia,\n      isEmpty: false\n    };\n\n    if (type === RuleType.CompiledStyle) {\n      rule.block = transformCC(content, selector);\n    } else if (type === RuleType.DynamicStyle) {\n      rule.block = content.replace(/\\|\\|\\&\\|\\|/g, selector);\n    }\n\n    rule.isReady = true;\n    rules.push(rule);\n  }\n\n  _appendDeclaration(rules, _type, content) {\n    if (!content) {\n      return;\n    }\n\n    let prevRule = rules[rules.length - 1];\n\n    if (prevRule && prevRule.isReady) {\n      prevRule = {\n        selector: prevRule.selector,\n        block: `${prevRule.selector}{`,\n        type: prevRule.type,\n        hasMedia: prevRule.hasMedia,\n        isEmpty: false\n      };\n      rules.push(prevRule);\n    }\n\n    prevRule.block += content;\n    prevRule.isEmpty = false;\n  }\n\n  _removeParentSelector(rules, selectors, resolvedSelectors) {\n    selectors.pop();\n    const prevRule = rules[rules.length - 1];\n    const currentRule = resolvedSelectors.pop();\n\n    if (!prevRule) {\n      return;\n    } // Close previous rule\n\n\n    if (!prevRule.isReady) {\n      prevRule.block += `}`;\n      prevRule.isReady = true;\n    }\n\n    if (currentRule && (currentRule.type === RuleType.MediaQuery || currentRule.type === RuleType.KeyFrame)) {\n      prevRule.block += `}`;\n      prevRule.isReady = true;\n    }\n  }\n\n}\n\nfunction transformCC(content, sel) {\n  content = content.replace(/\\/\\* >> cc[^\\/\\*]+\\*\\//g, '');\n  let expression = content.slice(2, content.length - 1);\n  expression = `st2c((${expression}), \\`${sel}\\`)`;\n  return `\\${${expression}}`;\n}\n\nfunction resolveSelectors(selectors, ignoreMediaQuery) {\n  let media = null;\n  const sel = selectors.filter(_ => {\n    if (typeof _ === 'string') {\n      if (!ignoreMediaQuery) {\n        media = _;\n      }\n\n      return false;\n    }\n\n    return !!_.filter(__ => __).length;\n  });\n  const sel2 = sel.length === 1 ? sel[0].join(',') : sel.length ? sel.reduce((prv, curr) => {\n    const result = prv.map(item => curr.map(cu => {\n      if (cu.includes('&')) {\n        return cu.replace(AMPERSAND_REGEX(), item);\n      }\n\n      return `${item} ${cu}`;\n    }));\n    return Array.prototype.concat.apply([], result);\n  }).join(',') : '';\n\n  if (media) {\n    return `${media}{${sel2}`;\n  }\n\n  return sel2;\n}\n\nfunction lyl(literals, ...placeholders) {\n  return className => {\n    let result = ''; // Save expressions\n\n    for (let i = 0; i < placeholders.length; i++) {\n      const placeholder = placeholders[i];\n      result += literals[i];\n\n      if (result.endsWith('...')) {\n        result = result.slice(0, result.length - 3);\n\n        if (typeof placeholder === 'function' || placeholder instanceof StyleCollection) {\n          result += `${createUniqueCommentSelector('ds')}${st2c(placeholder, '||&||')}`;\n        }\n      } else {\n        result += placeholder;\n      }\n    } // add the last literal\n\n\n    result += literals[literals.length - 1];\n    const css = new LylParse(result, className, false, true).toCss();\n    return css;\n  };\n}\n\nfunction createUniqueCommentSelector(text = 'id') {\n  return `/* >> ${text} -- ${Math.floor(new Date().valueOf() * Math.random()).toString(36)} */`;\n}\n\nclass StyleCollection {\n  constructor(...templates) {\n    this._templates = templates;\n    this.css = this.css.bind(this);\n  }\n\n  add(...templates) {\n    // return new StyleCollection(...[...this._templates, ...templates]);\n    this._templates.push(...templates);\n\n    return this;\n  }\n  /** Transform style */\n\n\n  setTransformer(transformer) {\n    this._transformer = transformer;\n    return this;\n  }\n  /**\n   * @return StyleTemplate\n   * @docs-private\n   */\n\n\n  css(className) {\n    let lin = '';\n    const templates = this._templates;\n\n    for (let index = 0; index < templates.length; index++) {\n      let template;\n\n      if (this._transformer) {\n        template = this._transformer(templates[index]);\n      } else {\n        template = templates[index];\n      }\n\n      lin += template(className);\n    }\n\n    return lin;\n  }\n\n}\n/**\n * Transform a ...{style} to css\n * For internal use purposes only\n * @param fn StyleTemplate or StyleCollection\n * @param className class name\n */\n\n\nfunction st2c(fn, className) {\n  if (fn == null) {\n    return '';\n  }\n\n  if (fn instanceof StyleCollection) {\n    return fn.css(className);\n  }\n\n  return fn(className);\n}\n\nclass StringIdGenerator {\n  constructor(chars = 'abcdefghijklmnopqrstuvwxyz') {\n    this._chars = chars;\n    this._nextId = [0];\n  }\n\n  next() {\n    const r = [];\n\n    for (const char of this._nextId) {\n      r.unshift(this._chars[char]);\n    }\n\n    this._increment();\n\n    return r.join('');\n  }\n\n  _increment() {\n    for (let i = 0; i < this._nextId.length; i++) {\n      const val = ++this._nextId[i];\n\n      if (val >= this._chars.length) {\n        this._nextId[i] = 0;\n      } else {\n        return;\n      }\n    }\n\n    this._nextId.push(0);\n  }\n\n}\n\nclass LyStyleUtils {\n  constructor() {\n    /** Returns top */\n    this.above = 'top';\n    /** Returns bottom */\n\n    this.below = 'bottom';\n  }\n  /** Returns left or right according to the direction */\n\n\n  get before() {\n    return this.getDirection(DirAlias.before);\n  }\n  /** Returns left or right according to the direction */\n\n\n  get after() {\n    return this.getDirection(DirAlias.after);\n  }\n\n  pxToRem(value) {\n    const size = this.typography.fontSize / 14;\n    return `${value / this.typography.htmlFontSize * size}rem`;\n  }\n\n  colorOf(value, optional) {\n    if (typeof value === 'number') {\n      return new Color(value);\n    }\n\n    if (value[0] === '#' && value.length === 7) {\n      return new Color(hexColorToInt(value));\n    }\n\n    const color = get(this, value, optional);\n\n    if (color) {\n      return color;\n    }\n    /** Create invalid color */\n\n\n    return new Color();\n  }\n\n  getBreakpoint(key) {\n    return `@media ${this.breakpoints[key] || key}`;\n  }\n\n  selectorsOf(styles) {\n    const styleMap = _STYLE_MAP.get(styles);\n\n    if (styleMap) {\n      return styleMap.classes || styleMap[this.name];\n    } else {\n      throw Error('Classes not found');\n    }\n  }\n\n  getDirection(val) {\n    if (val === DirAlias.before) {\n      return this.direction === 'rtl' ? 'right' : 'left';\n    } else if (val === DirAlias.after) {\n      return this.direction === 'rtl' ? 'left' : 'right';\n    } else if (val === 'above') {\n      return 'top';\n    } else if (val === 'below') {\n      return 'bottom';\n    }\n\n    return val;\n  }\n\n  isRTL() {\n    return this.direction === Dir.rtl;\n  }\n\n}\n\nvar Dir = /*#__PURE__*/(() => {\n  (function (Dir) {\n    Dir[\"rtl\"] = \"rtl\";\n    Dir[\"ltr\"] = \"ltr\";\n  })(Dir || (Dir = {}));\n\n  return Dir;\n})();\nvar DirAlias = /*#__PURE__*/(() => {\n  (function (DirAlias) {\n    DirAlias[\"before\"] = \"before\";\n    DirAlias[\"after\"] = \"after\";\n  })(DirAlias || (DirAlias = {}));\n\n  return DirAlias;\n})();\nvar DirPosition = /*#__PURE__*/(() => {\n  (function (DirPosition) {\n    DirPosition[\"left\"] = \"left\";\n    DirPosition[\"right\"] = \"right\";\n  })(DirPosition || (DirPosition = {}));\n\n  return DirPosition;\n})();\n\n/**\n * get color of object\n * @param obj object\n * @param path path\n * @param optional get optional value, if not exist return default if not is string\n */\nfunction get(obj, path, optional) {\n  var _a;\n\n  if (path === 'transparent') {\n    return new Color(0, 0, 0, 0);\n  }\n\n  const _path = path instanceof Array ? path : path.split(':');\n\n  for (let i = 0; i < _path.length; i++) {\n    const posibleOb = obj[_path[i]];\n\n    if (posibleOb) {\n      obj = posibleOb;\n    } else {\n      /** if not exist */\n      return new Color();\n    }\n  }\n\n  if (obj instanceof Color) {\n    return obj;\n  } else if (optional) {\n    return (_a = obj[optional]) !== null && _a !== void 0 ? _a : obj['default'];\n  } else {\n    return obj['default'];\n  } // return typeof obj === 'string' ? obj as string : obj['default'] as string;\n\n}\n/**\n * Extract breakpoints from a string to make it a unique `StyleTemplate`\n * @param str Media Queries in inline style\n * @param transformer A function with parameters to create a `StyleTemplate`\n * @deprecated\n */\n\n\nfunction withMediaInline(str, transformer) {\n  const styleCollection = new StyleCollection();\n\n  if (typeof str === 'string') {\n    const values = parseMediaQueriesFromString(str);\n\n    for (let index = 0; index < values.length; index++) {\n      parseMediaQueryFromString(values[index]).forEach(_ => {\n        styleCollection.add(transformer(_[0], _[1]));\n      });\n    }\n  } else if (typeof str === 'number' || str === null || str === undefined) {\n    styleCollection.add(transformer(str, null));\n  } else {\n    for (let index = 0; index < str.length; index++) {\n      const val = str[index];\n\n      if (typeof val === 'number' || val === null || val === undefined) {\n        styleCollection.add(transformer(val, null));\n      } else if (typeof val === 'string') {\n        parseMediaQueryFromString(val).forEach(_ => {\n          styleCollection.add(transformer(_[0], _[1]));\n        });\n      }\n    }\n  }\n\n  return styleCollection.css;\n}\n/**\n * Extract media query from a string\n */\n\n\nconst parseMediaQueryFromString = memoize(key => {\n  const valItem = key.split(/\\@/g);\n  const strValue = valItem.shift();\n  const len = valItem.length;\n  const value = isNaN(+strValue) ? strValue : +strValue;\n  const re = [];\n\n  if (len) {\n    for (let j = 0; j < len; j++) {\n      re.push([value, valItem[j]]);\n    }\n  } else {\n    re.push([value, null]);\n  }\n\n  return re;\n});\n/**\n * Extract media queries from a string\n */\n\nconst parseMediaQueriesFromString = memoize(key => {\n  return key.split(' ');\n});\n/**\n * @depracated use `withMediaInline` instead.\n */\n\nfunction eachMedia(str, fn, withStyleCollection) {\n  let styleCollection;\n\n  if (withStyleCollection) {\n    styleCollection = new StyleCollection();\n  }\n\n  if (typeof str === 'string') {\n    const values = str.split(/\\ /g);\n\n    for (let index = 0; index < values.length; index++) {\n      const valItem = values[index].split(/\\@/g);\n      const strValue = valItem.shift();\n      const len = valItem.length;\n      const value = isNaN(+strValue) ? strValue : +strValue;\n\n      if (len) {\n        for (let j = 0; j < len; j++) {\n          resolveMediaEachItemStyle(fn, value, valItem[j], index, styleCollection);\n        }\n      } else {\n        resolveMediaEachItemStyle(fn, value, null, index, styleCollection);\n      }\n    }\n  } else if (typeof str === 'number' || typeof str === 'string' || str === null || str === undefined) {\n    resolveMediaEachItemStyle(fn, str, null, 0, styleCollection);\n  } else {\n    // is array\n    for (let index = 0; index < str.length; index++) {\n      const val = str[index];\n\n      if (typeof val === 'number' || typeof val === 'string') {\n        resolveMediaEachItemStyle(fn, val, null, index, styleCollection);\n      } else {\n        const medias = val[1].split(/\\@/g).filter(media => media);\n        const strValue = val[0];\n        const len = medias.length;\n\n        if (len) {\n          for (let ii = 0; ii < len; ii++) {\n            resolveMediaEachItemStyle(fn, strValue, medias[ii], index, styleCollection);\n          }\n        } else {\n          resolveMediaEachItemStyle(fn, strValue, null, index, styleCollection);\n        }\n      }\n    }\n  }\n\n  if (styleCollection) {\n    return styleCollection.css;\n  }\n}\n\nfunction resolveMediaEachItemStyle(fn, val, media, index, styleCollection) {\n  const styl = fn(val, media, index);\n\n  if (styleCollection && styl) {\n    styleCollection.add(styl);\n  }\n}\n/**\n * Simple object check.\n * @param item\n */\n\n\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n/**\n * Deep merge two objects.\n * @param target\n * @param ...sources\n */\n\n\nfunction mergeDeep(target, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n\n  return mergeDeep(target, ...sources);\n}\n/**\n * Simple object check.\n * @param item\n */\n\n\nfunction isObjectForTheme(item) {\n  return item && typeof item === 'object' && !Array.isArray(item) && !(item instanceof StyleCollection) && !(item instanceof Color);\n}\n\nfunction mergeThemes(target, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObjectForTheme(target) && isObjectForTheme(source)) {\n    for (const key in source) {\n      if (isObjectForTheme(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        mergeThemes(target[key], source[key]);\n      } else {\n        const targetKey = target[key];\n        const sourceKey = source[key]; // Merge styles\n\n        if (targetKey instanceof StyleCollection && typeof sourceKey === 'function') {\n          target[key] = target[key].add(sourceKey);\n        } else if (sourceKey instanceof Color) {\n          target[key] = sourceKey;\n        } else {\n          // Object.assign(target, { [key]: source[key] });\n          target[key] = source[key];\n        }\n      }\n    }\n  }\n\n  return mergeThemes(target, ...sources);\n}\n\nlet CoreTheme = /*#__PURE__*/(() => {\n  class CoreTheme {\n    constructor(rendererFactory, _document, platform, _classNamePrefix) {\n      this.rendererFactory = rendererFactory;\n      this._classNamePrefix = _classNamePrefix;\n      this.themes = new Set();\n      this._themeMap = new Map();\n      this._styleMap = new Map();\n      this._document = _document;\n\n      if (!isDevMode() && _classNamePrefix) {\n        CoreTheme.classNamePrefix = this.classNamePrefix = _classNamePrefix;\n      }\n\n      if (platform.isBrowser) {\n        // Clean\n        const nodes = this._document.body.querySelectorAll('ly-s-c');\n\n        if (nodes.length) {\n          for (let index = 0; index < nodes.length; index++) {\n            const element = nodes.item(index);\n\n            this._document.body.removeChild(element);\n          }\n        }\n      }\n\n      this.firstElement = this._document.body.firstChild;\n      this.renderer = this.rendererFactory.createRenderer(null, {\n        id: 'ly',\n        encapsulation: ViewEncapsulation.None,\n        styles: [],\n        data: {}\n      });\n    }\n\n    initializeTheme(themeConfig, globalVariables) {\n      const allThemes = Array.isArray(themeConfig) ? themeConfig : [themeConfig];\n      const themes = new Map();\n      allThemes.forEach(item => {\n        // Do not install themes that are already initialized.\n        if (this.hasTheme(item.name)) {// throw new Error(`Theme '${item.name}' is already initialized.`);\n          // }\n        }\n\n        if (themes.has(item.name)) {\n          themes.get(item.name).push(item);\n        } else {\n          themes.set(item.name, [item]);\n        }\n      });\n      themes.forEach(items => {\n        if (globalVariables) {\n          items.push(globalVariables);\n        }\n\n        if (items.length > 1) {\n          mergeThemes(items[0], ...items.slice(1));\n        }\n\n        this._add(items[0]);\n\n        this.themes.add(items[0].name);\n      });\n    }\n    /**\n     * add new theme\n     * @param theme: ThemeVariables\n     */\n\n\n    _add(theme) {\n      this._themeMap.set(theme.name, theme);\n\n      this._styleMap.set(theme.name, new Map());\n    }\n\n    hasTheme(theme) {\n      const name = typeof theme === 'string' ? theme : theme.name;\n      return this._themeMap.has(name);\n    }\n\n    get(name) {\n      return this._themeMap.get(name);\n    }\n\n    updateClassName(element, renderer, newClassname, oldClassname) {\n      if (oldClassname) {\n        renderer.removeClass(element, oldClassname);\n      }\n\n      renderer.addClass(element, newClassname);\n    }\n\n  }\n\n  CoreTheme.ɵfac = function CoreTheme_Factory(t) {\n    return new (t || CoreTheme)(i0.ɵɵinject(i0.RendererFactory2), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i1.Platform), i0.ɵɵinject(LY_CLASS_NAME_PREFIX, 8));\n  };\n\n  CoreTheme.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CoreTheme,\n    factory: CoreTheme.ɵfac,\n    providedIn: 'root'\n  });\n  return CoreTheme;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar YPosition = /*#__PURE__*/(() => {\n  (function (YPosition) {\n    YPosition[\"above\"] = \"above\";\n    YPosition[\"below\"] = \"below\";\n  })(YPosition || (YPosition = {}));\n\n  return YPosition;\n})();\nvar XPosition = /*#__PURE__*/(() => {\n  (function (XPosition) {\n    XPosition[\"before\"] = \"before\";\n    XPosition[\"after\"] = \"after\";\n    XPosition[\"left\"] = \"left\";\n    XPosition[\"right\"] = \"right\";\n  })(XPosition || (XPosition = {}));\n\n  return XPosition;\n})();\nconst INITIAL_V = 'initial';\n/**\n * @deprecated Use `OverlayPosition` instead.\n */\n\nclass Positioning {\n  constructor(placement, xPosition, yPosition, origin, overlayElement, _themeVariables, _offset = 0, _flip = true) {\n    this.placement = placement;\n    this.xPosition = xPosition;\n    this.yPosition = yPosition;\n    this.origin = origin;\n    this.overlayElement = overlayElement;\n    this._themeVariables = _themeVariables;\n    this._offset = _offset;\n    this._offsetCheck = 16;\n    this._originRect = this.origin.getBoundingClientRect();\n    this._overlayElementRect = this.overlayElement.getBoundingClientRect();\n    this.width = INITIAL_V;\n    this.height = INITIAL_V;\n    const offsetCheckx2 = this._offsetCheck * 2;\n    this.createPosition();\n\n    if (_flip) {\n      for (let index = 0; index < 2; index++) {\n        if (this.checkAll(false, true)) {\n          this.createPosition();\n        }\n      }\n    } // when there is not enough space\n\n\n    if (this.checkAll(true, false)) {\n      let requireUpdateOrigin = false;\n\n      const _max_width = this._overlayElementRect.width + offsetCheckx2 > window.innerWidth;\n\n      const _max_height = this._overlayElementRect.height + offsetCheckx2 > window.innerHeight;\n\n      if (_max_height) {\n        this.y = this._offsetCheck;\n        this.height = `${window.innerHeight - offsetCheckx2}px`;\n        requireUpdateOrigin = true;\n      } else if (this.checkBottom(false, false)) {\n        this.y += this.checkBottom(true, false);\n        requireUpdateOrigin = true;\n      } else if (this.checkTop(false, false)) {\n        this.y -= this.checkTop(true, false);\n        requireUpdateOrigin = true;\n      }\n\n      if (_max_width) {\n        this.x = this._offsetCheck;\n        this.width = `${window.innerWidth - offsetCheckx2}px`;\n        requireUpdateOrigin = true;\n      } else if (this.checkRight(false, false)) {\n        this.x += this.checkRight(true, false);\n        requireUpdateOrigin = true;\n      } else if (this.checkLeft(false, false)) {\n        this.x -= this.checkLeft(true, false);\n        requireUpdateOrigin = true;\n      }\n\n      if (requireUpdateOrigin) {\n        this.updateOrigin();\n      }\n    }\n\n    if (this._offset) {\n      this.updateOrigin();\n    } // round result\n\n\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.ax = Math.round(this.ax);\n    this.ay = Math.round(this.ay);\n  }\n\n  get offsetX() {\n    return typeof this._offset === 'number' ? this._offset : this._offset.x || 0;\n  }\n\n  get offsetY() {\n    return typeof this._offset === 'number' ? this._offset : this._offset.y || 0;\n  }\n\n  createPosition() {\n    if (this.xPosition && this.yPosition) {\n      throw new Error(`You can not use \\`xPosition\\` and \\`yPosition\\` together, use only one of them.`);\n    } // if ((this.xPosition || this.yPosition) && !this.placement) {\n    //   throw new Error(`\\`placement\\` is required.`);\n    // }\n\n\n    let x = this._originRect.x,\n        y = this._originRect.y,\n        ox = 'center',\n        oy = 'center'; // if (this.placement) {\n\n    if (this.placement === YPosition.above) {\n      x += (this._originRect.width - this._overlayElementRect.width) / 2;\n      y += -this._overlayElementRect.height;\n      oy = 'bottom'; // set offset\n\n      y -= this.offsetY;\n    } else if (this.placement === YPosition.below) {\n      x += (this._originRect.width - this._overlayElementRect.width) / 2;\n      y += this._originRect.height;\n      oy = 'top'; // set offset\n\n      y += this.offsetY;\n    } else {\n      const dir = this._themeVariables.getDirection(this.placement);\n\n      if (dir === DirPosition.left) {\n        ox = '100%';\n        x += -this._overlayElementRect.width;\n        y += (this._originRect.height - this._overlayElementRect.height) / 2; // set offset\n\n        x -= this.offsetX;\n      } else if (dir === DirPosition.right) {\n        ox = '0%';\n        x += this._originRect.width;\n        y += (this._originRect.height - this._overlayElementRect.height) / 2; // set offset\n\n        x += this.offsetX;\n      }\n    }\n\n    if (this.xPosition) {\n      const dir = this._themeVariables.getDirection(this.xPosition);\n\n      if (dir === DirPosition.right) {\n        ox = '0%';\n        x = this._originRect.x; // set offset\n\n        x += this.offsetX;\n      } else if (dir === DirPosition.left) {\n        ox = '100%';\n        x = this._originRect.x + this._originRect.width - this._overlayElementRect.width; // set offset\n\n        x -= this.offsetX;\n      }\n    } else if (this.yPosition) {\n      if (this.yPosition === YPosition.above) {\n        y = this._originRect.y + this._originRect.height - this._overlayElementRect.height;\n        oy = '100%'; // set offset\n\n        y += this.offsetY;\n      } else if (this.yPosition === YPosition.below) {\n        y = this._originRect.y;\n        oy = '0%'; // set offset\n\n        y -= this.offsetY;\n      }\n    } // }\n\n\n    this.x = x;\n    this.y = y;\n    this.ax = x;\n    this.ay = y;\n    this.ox = ox;\n    this.oy = oy;\n    return {\n      x: Math.round(x),\n      y: Math.round(y),\n      ox,\n      oy\n    };\n  }\n\n  checkLeft(returnVal, invertIfNeed) {\n    const rest = this.ax - this._offsetCheck;\n\n    if (returnVal) {\n      return rest;\n    }\n\n    if (rest < 0) {\n      if (invertIfNeed) {\n        if (this.placement !== YPosition.above && this.placement !== YPosition.below) {\n          this.placement = invertPlacement(this.placement);\n        }\n\n        if (this.xPosition) {\n          this.xPosition = invertPlacement(this.xPosition);\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  checkRight(returnVal, invertIfNeed) {\n    const rest = window.innerWidth - (this.ax + this._overlayElementRect.width + this._offsetCheck);\n\n    if (returnVal) {\n      return rest;\n    }\n\n    if (rest < 0) {\n      if (invertIfNeed) {\n        if (this.placement !== YPosition.above && this.placement !== YPosition.below) {\n          this.placement = invertPlacement(this.placement);\n        }\n\n        if (this.xPosition) {\n          this.xPosition = invertPlacement(this.xPosition);\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  checkTop(returnVal, invertIfNeed) {\n    const rest = this.ay - this._offsetCheck;\n\n    if (returnVal) {\n      return rest;\n    }\n\n    if (rest < 0) {\n      if (invertIfNeed) {\n        if (this.placement === YPosition.above || this.placement === YPosition.below) {\n          this.placement = invertPlacement(this.placement);\n        }\n\n        if (this.yPosition) {\n          this.yPosition = invertPlacement(this.yPosition);\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  checkBottom(returnVal, invertIfNeed) {\n    const rest = window.innerHeight - (this.ay + this._overlayElementRect.height + this._offsetCheck);\n\n    if (returnVal) {\n      return rest;\n    }\n\n    if (rest < 0) {\n      if (invertIfNeed) {\n        if (this.placement === YPosition.above || this.placement === YPosition.below) {\n          this.placement = invertPlacement(this.placement);\n        }\n\n        if (this.yPosition) {\n          this.yPosition = invertPlacement(this.yPosition);\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  checkAll(returnVal, invertIfNeed) {\n    return this.checkLeft(returnVal, invertIfNeed) || this.checkRight(returnVal, invertIfNeed) || this.checkTop(returnVal, invertIfNeed) || this.checkBottom(returnVal, invertIfNeed);\n  }\n\n  updateOrigin() {\n    // do not update if it is defined\n    if (this._origin) {\n      return;\n    }\n\n    this._origin = true;\n    const oax = this._originRect.x + this._originRect.width / 2;\n    const oay = this._originRect.y + this._originRect.height / 2;\n    const vax = this.x + this._overlayElementRect.width / 2;\n    const vay = this.y + this._overlayElementRect.height / 2;\n    this.ox = `${oax - vax + this._overlayElementRect.width / 2}px`;\n    this.oy = `${oay - vay + this._overlayElementRect.height / 2}px`;\n  }\n\n}\n\nfunction invertPlacement(placement) {\n  if (placement === YPosition.above) {\n    return YPosition.below;\n  } else if (placement === YPosition.below) {\n    return YPosition.above;\n  } else if (placement === XPosition.after) {\n    return XPosition.before;\n  } else if (placement === XPosition.before) {\n    return XPosition.after;\n  } else if (placement === XPosition.right) {\n    return XPosition.left;\n  } else if (placement === XPosition.left) {\n    return XPosition.right;\n  }\n\n  return placement;\n}\n\nconst REF_REG_EXP = /\\{([\\w-]+)\\}/g;\nlet nextKeyFrameId = 0;\nconst yClassID = new StringIdGenerator();\nconst keyframesUniqueId = new StringIdGenerator();\nlet StylesInDocument = /*#__PURE__*/(() => {\n  class StylesInDocument {\n    constructor() {\n      this.styles = {};\n      this.styleContainers = new Map();\n      this.styleElementGlobalMap = new Map();\n    }\n\n  }\n\n  StylesInDocument.ɵfac = function StylesInDocument_Factory(t) {\n    return new (t || StylesInDocument)();\n  };\n\n  StylesInDocument.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StylesInDocument,\n    factory: StylesInDocument.ɵfac,\n    providedIn: 'root'\n  });\n  return StylesInDocument;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst THEME_MAP = new Map();\nlet LyTheme2 = /*#__PURE__*/(() => {\n  class LyTheme2 {\n    constructor(stylesInDocument, core, themeName, themeConfig, globalVariables, _document, _ngZone, _platform) {\n      this.stylesInDocument = stylesInDocument;\n      this.core = core;\n      this._ngZone = _ngZone;\n      this._platform = _platform;\n      this._elementsMap = new Map();\n      /** Event emitted when the direction has changed. */\n\n      this._directionChanged = new Subject();\n      /** Event emitted when the theme has changed. */\n\n      this._themeChanged = new Subject();\n      this.themeChanged = this._themeChanged.asObservable();\n      this.themeMap = THEME_MAP;\n      /** ssr or hmr */\n\n      this.isDevOrServer = isDevMode() || !this._platform.isBrowser;\n      this._document = _document;\n\n      if (themeConfig) {\n        core.initializeTheme(themeConfig, globalVariables);\n      }\n\n      if (themeName) {\n        this.setUpTheme(themeName);\n      }\n    }\n\n    get directionChanged() {\n      return this._directionChanged.asObservable();\n    }\n    /** Get Theme Variables */\n\n\n    get variables() {\n      return this.config;\n    }\n\n    setUpTheme(themeName) {\n      if (!this.config) {\n        const theme = this.core.get(themeName);\n\n        if (theme === undefined) {\n          throw new Error(`Theme ${themeName} not found in CoreTheme`);\n        }\n\n        this.config = theme;\n        this._styleMap = new Map();\n        this.elements = themeName in this.stylesInDocument.styles ? this.stylesInDocument.styles[themeName] : this.stylesInDocument.styles[themeName] = new Map();\n\n        if (!this.initialTheme) {\n          this.initialTheme = this.config.name;\n        }\n\n        if (!this.themeMap.has(this.initialTheme)) {\n          this.themeMap.set(this.initialTheme, {\n            base: this.initialTheme,\n            change: null\n          });\n        }\n      }\n    }\n    /**\n     * Build multiple styles and render them in the DOM\n     */\n\n\n    renderStyleSheet(styles) {\n      return this._createStyleContent2(styles, null, null, TypeStyle.Multiple);\n    }\n    /**\n     * Build the styles and render them in the DOM\n     */\n\n\n    renderStyle(styleOrId, priorityOrStyle, priority) {\n      if (typeof styleOrId === 'string') {\n        return this._createStyleContent2(priorityOrStyle, styleOrId, priority, TypeStyle.LylStyle);\n      }\n\n      return this._createStyleContent2(styleOrId, null, priorityOrStyle, TypeStyle.LylStyle);\n    }\n    /**\n     * Add a new dynamic style, use only within @Input()\n     * @param id Unique id\n     * @param style Styles\n     * @param el Element\n     * @param instance The instance of this, this replaces the existing style with a new one when it changes\n     * @param parentStyle Parent Style\n     */\n\n\n    addStyle(id, style, el, instance, priority, parentStyle) {\n      const newClass = this._createStyleContent2(style, id, priority, TypeStyle.OnlyOne, false, parentStyle);\n\n      if (newClass === instance) {\n        return newClass;\n      }\n\n      if (el) {\n        if (instance) {\n          el.classList.remove(instance);\n        }\n\n        el.classList.add(newClass);\n      }\n\n      return newClass;\n    }\n    /**\n     * Create basic style\n     * @param style Styles.\n     * Note: Use only with immutable variable.\n     * @param priority Priority of style\n     * @param parentStyle\n     */\n\n\n    style(style, priority, parentStyle) {\n      return this._createStyleContent2(style, null, priority, TypeStyle.OnlyOne, false, parentStyle);\n    }\n\n    updateClassName(element, renderer, newClassname, oldClassname) {\n      this.core.updateClassName(element, renderer, newClassname, oldClassname);\n    }\n\n    updateClass(element, renderer, newClass, oldClass) {\n      if (newClass === oldClass) {\n        return newClass;\n      }\n\n      this.updateClassName(element, renderer, newClass, oldClass);\n      return newClass;\n    }\n    /**\n     * Change the current theme for another.\n     * @param themeName theme name\n     */\n\n\n    setTheme(themeName) {\n      if (!this._platform.isBrowser) {\n        throw new Error(`\\`theme.setTheme('theme-name')\\` is only available in browser platform`);\n      }\n\n      if (themeName !== this.config.name) {\n        const theme = this.themeMap.get(this.initialTheme);\n        const dir = this.config.direction;\n\n        if (theme == null) {\n          throw new Error(`Theme ${themeName} not found in themeMap`);\n        }\n\n        theme.change = themeName;\n        this.config = this.core.get(themeName);\n        this.config.direction = dir;\n\n        this._updateAllStyles();\n\n        this._themeChanged.next();\n      }\n    }\n    /** Toggle right-to-left/left-to-right */\n\n\n    toggleDirection() {\n      const current = this.config.direction;\n      this.config.direction = current === Dir.ltr ? Dir.rtl : Dir.ltr;\n\n      this._updateAllStyles();\n\n      this._directionChanged.next();\n    }\n\n    setDirection(dir) {\n      if (this.config.direction !== dir) {\n        this.config.direction = dir;\n\n        this._updateAllStyles();\n\n        this._directionChanged.next();\n      }\n    }\n\n    _updateAllStyles() {\n      this.elements.forEach((_, key) => {\n        const styleData = _STYLE_MAP.get(key);\n\n        if (styleData.requireUpdate) {\n          this._createStyleContent2(styleData.styles, styleData.id, styleData.priority, styleData.type, true, styleData.parentStyle);\n        }\n      });\n    }\n    /**\n     * Create a simple style\n     * return className\n     * @param id id of style\n     * @param css style object or string\n     * @param priority style priority(default: 0)\n     */\n\n\n    addSimpleStyle(id, css, priority, parentStyle) {\n      return this._createStyleContent2(css, id, priority, TypeStyle.OnlyOne, false, parentStyle);\n    }\n    /**\n     * Add new add a new style sheet\n     * @param styles styles\n     * @param priority priority for style\n     */\n\n\n    addStyleSheet(styles, priority) {\n      return this._createStyleContent2(styles, null, priority, TypeStyle.Multiple);\n    }\n    /**\n     * Check if a style exist\n     * @param stylesOrId Style or Id of a style\n     */\n\n\n    existStyle(stylesOrId) {\n      if (_STYLE_MAP.has(stylesOrId)) {\n        const styleMap = _STYLE_MAP.get(stylesOrId);\n\n        return !!(styleMap.classes || styleMap[this.initialTheme]);\n      }\n\n      return false;\n    }\n    /**\n     * return selectors if exists\n     *\n     * e.g.\n     *\n     * ```ts\n     * {\n     *   root: '.c'\n     * }\n     * ```\n     * @param styles id\n     */\n\n\n    selectorsOf(styles) {\n      const themeName = this.initialTheme;\n\n      if (!_STYLE_MAP.has(styles)) {\n        _STYLE_MAP.set(styles, {\n          isNewStyle: true,\n          styles: styles,\n          type: TypeStyle.Multiple,\n          css: {},\n          id: null\n        });\n      }\n\n      const styleMap = _STYLE_MAP.get(styles);\n\n      const themeNameForSelectors = getThemeNameForSelectors(themeName);\n      const classesMap = styleMap[themeNameForSelectors] || (styleMap[themeNameForSelectors] = {});\n      return classesMap;\n    }\n\n    selectorOf(styles) {\n      const themeName = this.initialTheme;\n\n      const styleMap = _STYLE_MAP.get(styles);\n\n      return styleMap.classes || styleMap[themeName];\n    }\n    /**\n     * For internal use only\n     * @docs-private\n     */\n\n\n    _createStyleContent2(styles, id, priority, type, forChangeTheme, parentStyle) {\n      const newId = id || styles;\n\n      if (!_STYLE_MAP.has(newId)) {\n        _STYLE_MAP.set(newId, {\n          isNewStyle: true,\n          priority,\n          styles: styles,\n          type,\n          css: {},\n          id,\n          parentStyle\n        });\n      }\n\n      const styleMap = _STYLE_MAP.get(newId);\n\n      const themeName = this.initialTheme;\n      const isCreated = styleMap.isNewStyle || !(styleMap.classes || styleMap[themeName]);\n\n      if (isCreated || forChangeTheme) {\n        styleMap.isNewStyle = false; // create new style for new theme\n\n        let css;\n        const themeMap = this.themeMap.get(this.initialTheme);\n        const config = this.core.get(themeMap.change || themeName);\n\n        if (typeof styles === 'function') {\n          styleMap.requireUpdate = true;\n          css = type === TypeStyle.LylStyle ? createLylStyle(styleMap, styles(config, this), themeName, this.core.classNamePrefix) : groupStyleToString(styleMap, styles(config, this), themeName, id, type, config, this.core.classNamePrefix);\n\n          if (!forChangeTheme) {\n            styleMap.css[themeName] = css;\n          }\n        } else {\n          /** create a new id for style that does not <-<require>-> changes */\n          css = groupStyleToString(styleMap, styles, themeName, newId, type, config, this.core.classNamePrefix);\n          styleMap.css = css;\n        }\n\n        if (!this.elements.has(newId)) {\n          const newEl = this._createStyleElement();\n\n          if (styleMap.requireUpdate) {\n            // This is required for when a theme changes\n            this.elements.set(newId, newEl);\n          } else if (this.isDevOrServer) {\n            // in dev mode or server it is not necessary\n            // since the styles will not change\n            this.stylesInDocument.styleElementGlobalMap.set(newId, newEl);\n          }\n\n          this._renderCss(newEl, css, styleMap.priority);\n        }\n\n        if (forChangeTheme) {\n          const el = this.elements.get(newId);\n          el.removeChild(el.firstChild);\n          el.appendChild(this._document.createTextNode(css));\n        }\n      } else if (this.isDevOrServer) {\n        /**\n         * append child style if not exist in dom\n         * for ssr or hmr\n         */\n        if (!this.elements.has(newId)) {\n          const _css = styleMap.css[themeName] || styleMap.css;\n\n          const map = this.stylesInDocument.styleElementGlobalMap;\n\n          if (styleMap.requireUpdate) {\n            const styleElement = this._createStyleElement();\n\n            this.elements.set(newId, styleElement);\n\n            this._renderCss(styleElement, _css, styleMap.priority);\n          } else if (!map.has(newId)) {\n            const styleElement = this._createStyleElement();\n\n            map.set(newId, styleElement);\n\n            this._renderCss(styleElement, _css, styleMap.priority);\n          }\n        }\n      }\n\n      return styleMap.classes || styleMap[themeName];\n    }\n\n    _createStyleContainer(priority) {\n      priority = priority !== null && priority !== void 0 ? priority : 0;\n      const {\n        styleContainers\n      } = this.stylesInDocument;\n\n      if (!styleContainers.has(priority)) {\n        const el = this.core.renderer.createElement(`ly-s-c`);\n\n        if (isDevMode()) {\n          this.core.renderer.setAttribute(el, 'priority', `${priority}`);\n        }\n\n        styleContainers.set(priority, el);\n\n        if (styleContainers.size === 0) {\n          this.core.renderer.insertBefore(this._document.body, el, this._document.body.firstChild);\n          return el;\n        }\n      } else {\n        return styleContainers.get(priority);\n      }\n\n      const refChild = this.findNode(priority);\n      this.core.renderer.insertBefore(this._document.body, styleContainers.get(priority), refChild);\n      return styleContainers.get(priority);\n    }\n\n    findNode(index) {\n      const {\n        styleContainers\n      } = this.stylesInDocument;\n      const keys = Array.from(styleContainers.keys()).sort();\n      const key = keys.find(_ => index < _);\n      return key !== undefined && styleContainers.get(key) || this.core.firstElement;\n    }\n\n    _createStyleElement() {\n      const styleElement = this._document.createElement('style');\n\n      return styleElement;\n    }\n\n    _renderCss(styleElement, css, priority) {\n      const container = this._createStyleContainer(priority);\n\n      styleElement.appendChild(this._document.createTextNode(css));\n      container.appendChild(styleElement);\n    }\n\n    requestAnimationFrame(fn) {\n      if (typeof requestAnimationFrame === 'function') {\n        this._ngZone.runOutsideAngular(() => {\n          requestAnimationFrame(() => {\n            fn();\n          });\n        });\n      } else {\n        fn();\n      }\n    }\n\n  }\n\n  LyTheme2.ɵfac = function LyTheme2_Factory(t) {\n    return new (t || LyTheme2)(i0.ɵɵinject(StylesInDocument), i0.ɵɵinject(CoreTheme), i0.ɵɵinject(LY_THEME_NAME), i0.ɵɵinject(LY_THEME, 8), i0.ɵɵinject(LY_THEME_GLOBAL_VARIABLES, 8), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.Platform));\n  };\n\n  LyTheme2.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LyTheme2,\n    factory: LyTheme2.ɵfac\n  });\n  return LyTheme2;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction createLylStyle(styleMap, styles, themeName, classNamePrefix) {\n  // use current class or set new\n  let className;\n  className = styleMap[themeName] || (styleMap[themeName] = isDevMode() ? styleMap.id ? `${toValidClassName(styleMap.id)}-${createNextClassId(classNamePrefix)}` : `${styleMap.styles.name || 'ii'}-${createNextClassId(classNamePrefix)}` : createNextClassId(classNamePrefix));\n  return styles(`.${className}`);\n}\n\nfunction groupStyleToString(styleMap, styles, themeName, id, typeStyle, themeVariables, classNamePrefix) {\n  // for styles type string\n  if (typeStyle === TypeStyle.OnlyOne) {\n    // use current class or set new\n    const className = styleMap.requireUpdate ? styleMap[themeName] || (styleMap[themeName] = createNextClassId(classNamePrefix)) : styleMap.classes ? styleMap.classes : styleMap.classes = createNextClassId(classNamePrefix);\n    let rules;\n\n    if (typeof styles === 'string') {\n      rules = `.${className}{${styles}}`;\n    } else {\n      rules = styleToString(id, null, styles, themeVariables, className);\n    }\n\n    if (styleMap.parentStyle) {\n      const styleMapOfParentStyle = _STYLE_MAP.get(styleMap.parentStyle);\n\n      if (!styleMapOfParentStyle) {\n        throw new Error(`The parentStyle not exist or is called before being created.`);\n      }\n\n      return replaceRefs(rules, styleMapOfParentStyle[themeName]);\n    }\n\n    return rules;\n  } // for multiples styles\n\n\n  const themeNameForSelectors = getThemeNameForSelectors(themeName);\n  const classesMap = styleMap[themeName] || (styleMap[themeName] = {});\n  const selectorsMap = styleMap[themeNameForSelectors] || (styleMap[themeNameForSelectors] = {});\n  const styleGroup = styles;\n  let content = '';\n  const name = styleGroup.$name ? `${styleGroup.$name}-` : ''; // set priority\n\n  if (styleGroup.$priority != null) {\n    styleMap.priority = styleGroup.$priority;\n  }\n\n  if (!styleMap.keys) {\n    styleMap.keys = Object.keys(styles);\n  }\n\n  const keys = styleMap.keys;\n  /** This loop creates the classes if necessary */\n\n  for (let index = 0; index < keys.length; index++) {\n    const key = keys[index];\n    const value = styles[key];\n\n    if (key === '$global' || key === '$keyframes') {\n      continue;\n    }\n\n    if (typeof value === 'function') {\n      // lyl\n      // set new id if not exist\n      if (!(key in classesMap)) {\n        classesMap[key] = isDevMode() ? key === 'root' ? `${toValidClassName(name)}${createNextClassId(classNamePrefix)}` : `${toValidClassName(name + key)}-${createNextClassId(classNamePrefix)}` : createNextClassId(classNamePrefix);\n      }\n    } else if (typeof value === 'object' || value === null) {\n      // TODO: @deprecated\n      // remove this in the future\n      // set new id if not exist\n      if (!(key in classesMap)) {\n        classesMap[key] = isDevMode() ? toValidClassName(`y-${name}${key}-${createNextClassId(classNamePrefix)}`) : createNextClassId(classNamePrefix);\n      }\n    } else {\n      continue;\n    }\n\n    if (!(key in selectorsMap)) {\n      selectorsMap[key] = `.${classesMap[key]}`;\n    }\n  }\n\n  let requireReplaceRefs = false;\n\n  for (let index = 0; index < keys.length; index++) {\n    const key = keys[index];\n    const value = styles[key];\n\n    if (typeof value === 'function') {\n      // lyl\n      if (key === '$global') {\n        if (value.length) {\n          content += value(``);\n        } else {\n          content += value()(``);\n        }\n      } else {\n        const selector = selectorsMap[key];\n\n        if (value.length) {\n          content += value(selector);\n        } else {\n          const st = value();\n\n          if (st) {\n            content += st(selector);\n          }\n        }\n      }\n    } else if (key === '$keyframes') {\n      console.warn(`'$keyframes' is deprecated, use '$global' instead to create keyframes.`);\n      requireReplaceRefs = true;\n      content += keyframesToString(name, classesMap, value, themeVariables);\n    } else if (typeof value === 'object' && value !== null) {\n      requireReplaceRefs = true;\n      const currentClassName = classesMap[key];\n      const style = styleToString(key, styleGroup.$name, value, themeVariables, currentClassName);\n      content += style;\n\n      if (value === null) {\n        console.warn(`__`, {\n          style\n        });\n      }\n    } // ignore if value === null\n\n  }\n\n  if (requireReplaceRefs) {\n    return replaceRefs(content, classesMap);\n  }\n\n  return content;\n}\n\nfunction replaceRefs(str, data) {\n  return str.replace(REF_REG_EXP, (_match, token) => {\n    const className = data[token];\n\n    if (className) {\n      return `.${data[token]}`;\n    } else {\n      return data[`@г.->-${token}`];\n    }\n  });\n}\n/**\n * {color:'red'} to .className{color: red}\n */\n\n\nfunction styleToString(key, $name, ob, themeVariables, currentKey, parentKey) {\n  let content = '';\n  let subContent = '';\n  let keyAndValue = '';\n  let newKey;\n\n  if (parentKey) {\n    if (currentKey.indexOf('&') !== -1) {\n      newKey = currentKey.replace(/&/g, parentKey);\n    } else if (currentKey.indexOf('@media') === 0) {\n      newKey = `${currentKey}`;\n    } else if (currentKey === '@global' || parentKey === '@global') {\n      newKey = currentKey;\n    } else {\n      newKey = `${parentKey} ${currentKey}`;\n    }\n  } else if (key === '@global') {\n    newKey = key;\n  } else {\n    newKey = `.${currentKey}`;\n  }\n\n  for (const styleKey in ob) {\n    if (ob.hasOwnProperty(styleKey)) {\n      const element = ob[styleKey]; // Omit style with value null\n\n      if (element != null) {\n        // Check if is Object literal\n        if (element.constructor === Object) {\n          subContent += styleToString(key, $name, element, themeVariables, styleKey, newKey);\n        } else {\n          keyAndValue += convertToStyleValue(styleKey, element, themeVariables);\n        }\n      }\n    }\n  }\n\n  if (keyAndValue) {\n    if (isDevMode()) {\n      let lin = '\\n\\n';\n\n      if ($name) {\n        lin += `/** Style Sheet name: ${$name} */\\n`;\n      }\n\n      lin += `/** Style Key: ${key} */\\n`;\n      content += `${lin}`;\n    }\n\n    if (newKey.indexOf('@media') === 0) {\n      content += `${newKey}`;\n      keyAndValue = `${parentKey}{${keyAndValue}}`;\n    } else if (parentKey && parentKey === '@global') {\n      content += `${currentKey}`;\n    } else {\n      content += `${newKey}`;\n    }\n\n    content += `{${keyAndValue}}`;\n  }\n\n  return content + subContent;\n}\n\nfunction convertToStyleValue(key, value, themeVariables) {\n  const newStyleKey = converterToCssKeyAndStyleCache(key, themeVariables);\n\n  if (value.constructor === Array) {\n    let lin = '';\n\n    for (let index = 0; index < value.length; index++) {\n      lin += `${newStyleKey}:${value[index]};`;\n    }\n\n    return lin;\n  } else {\n    return `${newStyleKey}:${value};`;\n  }\n}\n\nfunction keyframesToString(styleName, keysMap, keyframes, themeVariables) {\n  let content = '';\n\n  for (const name in keyframes) {\n    if (keyframes.hasOwnProperty(name)) {\n      const keyframe = keyframes[name]; // Sometimes the name of a class can be the same as the name of a keyframe,\n      // so we add a character to be different\n\n      const newUniqueName = `@г.->-${name}`; // set new id if not exist\n\n      const newName = newUniqueName in keysMap ? keysMap[newUniqueName] : keysMap[newUniqueName] = isDevMode() ? toValidClassName(`${styleName}${name}-${createNextKeyframeId()}-v`) : createNextKeyframeId();\n      content += `@keyframes ${newName}{`;\n\n      for (const percent in keyframe) {\n        if (keyframe.hasOwnProperty(percent)) {\n          content += `${percent}%{`;\n          const styles = keyframe[percent];\n\n          for (const key in styles) {\n            if (styles.hasOwnProperty(key)) {\n              const val = styles[key];\n              content += convertToStyleValue(key, val, themeVariables);\n            }\n          }\n\n          content += `}`;\n        }\n      }\n\n      content += `}`;\n    }\n  }\n\n  return content;\n}\n\nfunction converterToCssKeyAndStyle(str, themeVariables) {\n  const hyphenCase = toHyphenCase(str);\n\n  if (hyphenCase.indexOf(DirAlias.before) !== -1) {\n    return dirCache(str, hyphenCase, themeVariables, DirAlias.before);\n  } else if (hyphenCase.indexOf(DirAlias.after) !== -1) {\n    return dirCache(str, hyphenCase, themeVariables, DirAlias.after);\n  } else if (hyphenCase.indexOf(YPosition.above) !== -1) {\n    return YPositionCache(str, hyphenCase, themeVariables, YPosition.above, TOP);\n  } else if (hyphenCase.indexOf(YPosition.below) !== -1) {\n    return YPositionCache(str, hyphenCase, themeVariables, YPosition.below, BOTTOM);\n  }\n\n  return hyphenCase;\n}\n\nfunction toValidClassName(str) {\n  const s = str.replace(/^[0-9]|[^\\w\\-]/g, _ => {\n    return `_${_.charCodeAt(0)}`;\n  });\n  return s;\n}\n\nfunction toHyphenCase(str) {\n  return str.replace(/([A-Z])/g, g => `-${g[0].toLowerCase()}`);\n}\n\nfunction converterToCssKeyAndStyleCache(str, themeVariables) {\n  const map = STYLE_KEYS_MAP[themeVariables.direction];\n  return str in map ? map[str] : map[str] = converterToCssKeyAndStyle(str, themeVariables);\n}\n\nconst ignoreCSSKEY = {\n  'break-after': 'break-after',\n  'break-before': 'break-before',\n  'page-break-after': 'page-break-after',\n  'page-break-before': 'page-break-before'\n};\nconst STYLE_KEYS_MAP = {\n  rtl: Object.assign({}, ignoreCSSKEY),\n  ltr: Object.assign({}, ignoreCSSKEY)\n};\nconst BOTTOM = 'bottom';\nconst TOP = 'top';\n\nfunction dirCache(original, val, themeVariables, dirAlias) {\n  const map = STYLE_KEYS_MAP[themeVariables.direction]; // Replace in original, for do not repeat this again\n\n  return map[original] = val.replace(dirAlias, themeVariables.getDirection(dirAlias));\n}\n\nfunction YPositionCache(original, val, themeVariables, pos, to) {\n  const map = STYLE_KEYS_MAP[themeVariables.direction]; // Replace in original, for do not repeat this again\n\n  return map[original] = val.replace(pos, to);\n}\n\nfunction capitalizeFirstLetter(str) {\n  return str[0].toUpperCase() + str.slice(1);\n}\n\nfunction createNextClassId(classNamePrefix) {\n  return classNamePrefix ? `${classNamePrefix}${yClassID.next()}` : yClassID.next();\n}\n/**\n * Create next class id from key\n * @private\n */\n\n\nconst ck = memoize(_key => {\n  return createNextClassId(CoreTheme.classNamePrefix);\n});\n/**\n * Create next selector id from key\n */\n\nconst dot = memoize(key => {\n  return `.${ck(key)}`;\n});\n\nfunction createNextKeyframeId() {\n  return `k${(nextKeyFrameId++).toString(36)}`;\n}\n\nconst LY_COMMON_STYLES = {\n  fill: _className => `${_className}{position:absolute;top:0;bottom:0;left:0;right:0;}`,\n  visuallyHidden: _className => `${_className}{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;outline:0;-webkit-appearance:none;-moz-appearance:none;}`,\n  button: _className => `${_className}{-webkit-tap-highlight-color:transparent;background-color:transparent;border:0;-moz-appearance:none;-webkit-appearance:none;margin:0;outline:none;box-sizing:border-box;position:relative;text-decoration-line:none;-webkit-text-decoration-line:none;}${_className}::-moz-focus-inner{border:0;}`\n};\nconst LY_COMMON_STYLES_DEPRECATED = {\n  fill: {\n    position: 'absolute',\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  },\n  visuallyHidden: {\n    border: 0,\n    clip: 'rect(0 0 0 0)',\n    height: '1px',\n    margin: '-1px',\n    overflow: 'hidden',\n    padding: 0,\n    position: 'absolute',\n    width: '1px',\n    outline: 0,\n    '-webkit-appearance': 'none',\n    '-moz-appearance': 'none'\n  },\n  button: {\n    '-webkit-tap-highlight-color': 'transparent',\n    backgroundColor: `transparent`,\n    border: 0,\n    '-moz-appearance': 'none',\n    '-webkit-appearance': 'none',\n    margin: 0,\n    outline: 'none',\n    boxSizing: 'border-box',\n    position: 'relative',\n    textDecorationLine: 'none',\n    '-webkit-text-decoration-line': 'none',\n    '&::-moz-focus-inner': {\n      border: 0\n    }\n  }\n};\nlet LyCoreStyles = /*#__PURE__*/(() => {\n  class LyCoreStyles {\n    constructor(theme) {\n      this.theme = theme;\n      this.classes = this.theme.addStyleSheet(LY_COMMON_STYLES_DEPRECATED);\n    }\n\n  }\n\n  LyCoreStyles.ɵfac = function LyCoreStyles_Factory(t) {\n    return new (t || LyCoreStyles)(i0.ɵɵinject(LyTheme2));\n  };\n\n  LyCoreStyles.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LyCoreStyles,\n    factory: LyCoreStyles.ɵfac,\n    providedIn: 'root'\n  });\n  return LyCoreStyles;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst styles$1 = theme => ({\n  rippleContainer: {\n    position: 'absolute',\n    width: '2px',\n    height: '2px',\n    background: 'currentColor',\n    opacity: '.2',\n    borderRadius: '50%',\n    transform: 'scale(0)',\n    transition: `opacity ${theme.ripple.transition.opacity},transform ${theme.ripple.transition.transform}`,\n    pointerEvents: 'none'\n  },\n  container: Object.assign(Object.assign({}, LY_COMMON_STYLES_DEPRECATED.fill), {\n    overflow: 'hidden',\n    pointerEvents: 'none',\n    borderRadius: 'inherit'\n  })\n});\n\nlet LyRippleService = /*#__PURE__*/(() => {\n  class LyRippleService {\n    constructor(theme) {\n      this.theme = theme;\n      this.classes = this.theme.addStyleSheet(styles$1);\n    }\n\n  }\n\n  LyRippleService.ɵfac = function LyRippleService_Factory(t) {\n    return new (t || LyRippleService)(i0.ɵɵinject(LyTheme2));\n  };\n\n  LyRippleService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LyRippleService,\n    factory: LyRippleService.ɵfac,\n    providedIn: 'root'\n  });\n  return LyRippleService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction mixinDisableRipple(base) {\n  return class extends base {\n    constructor(...args) {\n      super(...args);\n      this._rippleConfig = {};\n    }\n\n    get disableRipple() {\n      return this._disableRipple;\n    }\n\n    set disableRipple(val) {\n      if (this._platform.isBrowser && val !== this._disableRipple) {\n        const newVal = this._disableRipple = toBoolean(val); // remove previous ripple if exist\n\n        this._removeRippleEvents();\n\n        if (!newVal) {\n          // add ripple\n          Promise.resolve(null).then(() => {\n            const triggerElement = this._triggerElement.nativeElement;\n            const rippleContainer = this._rippleContainer && this._rippleContainer.nativeElement || triggerElement;\n            this._ripple = new Ripple(this._theme.variables, this._ngZone, this._theme.addStyleSheet(styles$1), rippleContainer, this._platform, triggerElement);\n\n            this._ripple.setConfig(this._rippleConfig);\n          });\n        }\n      }\n    }\n\n    _removeRippleEvents() {\n      if (this._platform.isBrowser) {\n        if (this._ripple) {\n          this._ripple.removeEvents();\n\n          this._ripple = null;\n        }\n      }\n    }\n\n  };\n}\n\nfunction mixinDisabled(base) {\n  return class extends base {\n    constructor(...args) {\n      super(...args);\n      this._superHyperInternalPropertyDisabled = false;\n    }\n\n    get disabled() {\n      return this._superHyperInternalPropertyDisabled;\n    }\n\n    set disabled(value) {\n      this._superHyperInternalPropertyDisabled = toBoolean(value);\n    }\n\n  };\n}\n\nfunction mixinColor(base) {\n  return class extends base {\n    constructor(...args) {\n      super(...args);\n    }\n\n    get color() {\n      return this._superHyperInternalPropertyColor;\n    }\n\n    set color(val) {\n      const defaultColor = val;\n\n      if (defaultColor !== this.color) {\n        this._superHyperInternalPropertyColor = defaultColor;\n      }\n    }\n\n  };\n}\n\nfunction mixinBg(base) {\n  return class extends base {\n    constructor(...args) {\n      super(...args);\n    }\n\n    get bg() {\n      return this._superHyperInternalPropertyBg;\n    }\n\n    set bg(val) {\n      const defaultColor = val;\n\n      if (defaultColor !== this.bg) {\n        this._superHyperInternalPropertyBg = defaultColor;\n      }\n    }\n\n  };\n}\n\nfunction mixinRaised(base) {\n  return class extends base {\n    constructor(...args) {\n      super(...args);\n    }\n\n    get raised() {\n      return this._superHyperInternalPropertyRaised;\n    }\n\n    set raised(value) {\n      this._superHyperInternalPropertyRaised = toBoolean(value);\n    }\n\n  };\n}\n\nfunction mixinOutlined(base) {\n  return class extends base {\n    constructor(...args) {\n      super(...args);\n    }\n\n    get outlined() {\n      return this._superHyperInternalPropertyOutlined;\n    }\n\n    set outlined(value) {\n      this._superHyperInternalPropertyOutlined = toBoolean(value);\n    }\n\n  };\n}\n\nfunction mixinElevation(base) {\n  return class extends base {\n    constructor(...args) {\n      super(...args);\n    }\n\n    get elevation() {\n      return this._superHyperInternalPropertyElevation;\n    }\n\n    set elevation(value) {\n      this._superHyperInternalPropertyElevation = value;\n    }\n\n  };\n}\n\nfunction mixinShadowColor(base) {\n  return class extends base {\n    constructor(...args) {\n      super(...args);\n    }\n\n    get shadowColor() {\n      return this._superHyperInternalPropertyShadowColor;\n    }\n\n    set shadowColor(value) {\n      this._superHyperInternalPropertyShadowColor = value;\n    }\n\n  };\n}\n\nconst DEFAULT_TAB_INDEX = 0;\n\nfunction mixinTabIndex(base) {\n  return class extends base {\n    constructor(...args) {\n      super(...args);\n      this._tabIndex = DEFAULT_TAB_INDEX;\n    }\n\n    get tabIndex() {\n      return this.disabled ? -1 : this._tabIndex;\n    }\n\n    set tabIndex(value) {\n      this._tabIndex = value != null ? value : DEFAULT_TAB_INDEX;\n    }\n\n  };\n}\n\nconst DEFAULT_BG = 'paper';\n\nclass LyPaperBase {\n  constructor(_theme, _ngZone, _platform) {\n    this._theme = _theme;\n    this._ngZone = _ngZone;\n    this._platform = _platform;\n  }\n\n}\n\nconst LyPaperMixinBase = mixinStyleUpdater(mixinBg(mixinColor(mixinRaised(mixinOutlined(mixinElevation(mixinShadowColor(mixinDisableRipple(LyPaperBase))))))));\nlet LyPaper = /*#__PURE__*/(() => {\n  class LyPaper extends LyPaperMixinBase {\n    constructor(theme, ngZone, _el, _renderer, platform) {\n      super(theme, ngZone, platform);\n      this._el = _el;\n      this._renderer = _renderer;\n      this.setAutoContrast();\n      this._triggerElement = this._el;\n      this._rippleContainer = this._el;\n    }\n\n    set hasText(val) {\n      this._hasText = toBoolean(val);\n    }\n\n    get hasText() {\n      return this._hasText;\n    }\n\n    ngOnChanges() {\n      this.updateStyle(this._el);\n    }\n\n    ngOnInit() {\n      if (!this.bg && !this.hasText) {\n        this.bg = DEFAULT_BG;\n        this.updateStyle(this._el);\n\n        this._renderer.addClass(this._el.nativeElement, this._theme.addSimpleStyle('lyPaper', {\n          display: 'block'\n        }));\n      }\n    }\n\n    ngOnDestroy() {\n      this._removeRippleEvents();\n    }\n\n  }\n\n  LyPaper.ɵfac = function LyPaper_Factory(t) {\n    return new (t || LyPaper)(i0.ɵɵdirectiveInject(LyTheme2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.Platform));\n  };\n\n  LyPaper.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LyPaper,\n    selectors: [[\"ly-paper\"], [\"\", \"ly-paper\", \"\"], [\"\", \"ly-text\", \"\"]],\n    inputs: {\n      bg: \"bg\",\n      color: \"color\",\n      raised: \"raised\",\n      outlined: \"outlined\",\n      elevation: \"elevation\",\n      shadowColor: \"shadowColor\",\n      disableRipple: \"disableRipple\",\n      hasText: [\"ly-text\", \"hasText\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return LyPaper;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LyWithClass = /*#__PURE__*/(() => {\n  class LyWithClass {\n    constructor(el) {\n      this.el = el;\n    }\n\n    set withClass(val) {\n      if (!val) {\n        throw new Error(`'${val}' is not valid className`);\n      }\n\n      this.el.nativeElement.classList.add(val);\n    }\n\n  }\n\n  LyWithClass.ɵfac = function LyWithClass_Factory(t) {\n    return new (t || LyWithClass)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  LyWithClass.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LyWithClass,\n    selectors: [[\"\", \"withClass\", \"\"]],\n    inputs: {\n      withClass: \"withClass\"\n    }\n  });\n  return LyWithClass;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet StyleRenderer = /*#__PURE__*/(() => {\n  class StyleRenderer {\n    constructor(_theme, _el, _renderer) {\n      this._theme = _theme;\n      this._renderer = _renderer;\n      this._set = new Set();\n\n      if (_el) {\n        this._nEl = _el.nativeElement;\n        this._set = new Set();\n      }\n    }\n    /**\n     * Build multiple styles and render them in the DOM.\n     * @param styles Styles\n     * @param applyRootClass If `applyToRoot` is `true` and the root property is defined,\n     * it will automatically be added to the component.\n     *\n     * e.g.\n     *\n     * ```ts\n     * const STYLES = () => ({\n     *   root: lyl `{...}`, // this class will be added to the root component\n     *   item: lyl `{...}`\n     * })\n     * ```\n     *\n     * Also accepts the name of a class.\n     *\n     * e.g.\n     *\n     * ```ts\n     * renderSheet(STYLES, 'item')\n     * ```\n     */\n\n\n    renderSheet(styles, applyRootClass) {\n      const classes = this._theme.renderStyleSheet(styles);\n\n      if (applyRootClass === true && classes.root) {\n        this.addClass(classes.root);\n        return classes;\n      }\n\n      if (applyRootClass) {\n        const customClass = classes[applyRootClass];\n\n        if (customClass) {\n          this.addClass(customClass);\n        }\n      }\n\n      return classes;\n    }\n    /**\n     * Render style and apply class name to host Component or Directive,\n     * require provide `StyleRenderer` in your Component.\n     * e.g.\n     * @Component({\n     *   ...\n     *   providers: [ StyleRenderer ]\n     * })\n     */\n\n\n    add(id, style, priority, oldClass) {\n      const args = arguments;\n      /** Class name or keyframe name */\n\n      let className;\n      let len = args.length; // clean\n\n      if (len === 4 && args[3] == null) {\n        len -= 1;\n      }\n\n      if (len === 3 && args[2] == null) {\n        len -= 1;\n      }\n\n      if (len === 1) {\n        className = this._theme._createStyleContent2(id, null, null, TypeStyle.LylStyle);\n      } else if (len === 2) {\n        if (typeof id === 'string') {\n          className = this._theme._createStyleContent2(style, id, null, TypeStyle.LylStyle);\n        } else if (typeof style === 'number') {\n          className = this._theme._createStyleContent2(id, null, style, TypeStyle.LylStyle);\n        } else {\n          className = this._theme._createStyleContent2(id, null, null, TypeStyle.LylStyle);\n          oldClass = style;\n        }\n      } else if (len === 3) {\n        if (typeof id === 'string') {\n          if (typeof priority === 'number') {\n            // (id, style, priority)\n            className = this._theme._createStyleContent2(style, id, priority, TypeStyle.LylStyle);\n          } else {\n            // (id, style, oldClass)\n            className = this._theme._createStyleContent2(style, id, null, TypeStyle.LylStyle);\n            oldClass = priority;\n          }\n        } else {\n          // (style, priority, oldClass)\n          className = this._theme._createStyleContent2(id, null, style, TypeStyle.LylStyle);\n          oldClass = priority;\n        }\n      } else if (len === 4) {\n        className = this._theme._createStyleContent2(style, id, priority, TypeStyle.LylStyle);\n      }\n\n      if (this._nEl) {\n        return this.updateClass(className, oldClass);\n      }\n\n      throw new Error(`StyleRenderer is required on the Component!\\n` + `Add provider for StyleRenderer in Component or Directive:\\n\\n` + `e.g:\\n\\n` + `@Component({\\n` + `  providers: [ StyleRenderer ]\\n` + `})\\n`);\n    }\n    /**\n     * Only render style and return class name.\n     */\n\n\n    render(styleOrId, priorityOrStyle, priority) {\n      if (typeof styleOrId === 'string') {\n        return this._theme._createStyleContent2(priorityOrStyle, styleOrId, priority, TypeStyle.LylStyle);\n      }\n\n      return this._theme._createStyleContent2(styleOrId, null, priority, TypeStyle.LylStyle);\n    }\n\n    addClass(className) {\n      if (!this._set.has(className)) {\n        this._set.add(className);\n\n        this._renderer.addClass(this._nEl, className);\n      }\n    }\n\n    removeClass(className) {\n      if (className && this._set.has(className)) {\n        this._set.delete(className);\n\n        this._renderer.removeClass(this._nEl, className);\n      }\n    }\n\n    removeClasses(rawClassVal) {\n      if (rawClassVal) {\n        rawClassVal.forEach(klass => this.removeClass(klass));\n      }\n    }\n\n    toggleClass(className, enabled) {\n      if (enabled) {\n        this.addClass(className);\n      } else {\n        this.removeClass(className);\n      }\n    }\n\n    updateClass(newClassName, oldClassName) {\n      this.removeClass(oldClassName);\n      this.addClass(newClassName);\n      return newClassName;\n    }\n\n  }\n\n  StyleRenderer.ɵfac = function StyleRenderer_Factory(t) {\n    return new (t || StyleRenderer)(i0.ɵɵinject(LyTheme2), i0.ɵɵinject(i0.ElementRef, 8), i0.ɵɵinject(i0.Renderer2, 8));\n  };\n\n  StyleRenderer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StyleRenderer,\n    factory: StyleRenderer.ɵfac\n  });\n  return StyleRenderer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Parameter decorator to be used for create Dynamic style together with `@Input`\n * @param style style\n * @param formatWith A function to format the value\n * @decorator\n */\n\n\nfunction Style2(style, formatWith, priority) {\n  return function (target, propertyKey, descriptor) {\n    target.constructor[propertyKey] = style;\n    const _propertyKey = `_${propertyKey}Value`;\n\n    if (descriptor) {\n      const set = descriptor.set;\n\n      descriptor.set = function (val) {\n        const newValue = formatWith ? formatWith(val) : val;\n        createStyle(this, propertyKey, newValue, style, priority);\n        set.call(this, newValue);\n      };\n\n      if (!descriptor.get) {\n        descriptor.get = function () {\n          return this[_propertyKey];\n        };\n      }\n    } else {\n      Object.defineProperty(target, propertyKey, {\n        configurable: true,\n        enumerable: true,\n\n        set(val) {\n          const newValue = formatWith ? formatWith(val) : val;\n          createStyle(this, propertyKey, newValue, style, priority);\n        },\n\n        get() {\n          return this[_propertyKey];\n        }\n\n      });\n    }\n  };\n}\n/**\n * Parameter decorator to be used for create Dynamic style together with `@Input`\n * @param style style\n * @param priority priority of style, default: 0\n * @decorator\n */\n\n\nfunction Style(style, priority) {\n  return function (target, propertyKey, descriptor) {\n    target.constructor[propertyKey] = style;\n    const _propertyKey = `_${propertyKey}Value`;\n\n    if (descriptor) {\n      const set = descriptor.set;\n\n      descriptor.set = function (val) {\n        createStyle(this, propertyKey, val, style, priority);\n        set.call(this, val);\n      };\n\n      if (!descriptor.get) {\n        descriptor.get = function () {\n          return this[_propertyKey];\n        };\n      }\n    } else {\n      Object.defineProperty(target, propertyKey, {\n        configurable: true,\n        enumerable: true,\n\n        set(val) {\n          createStyle(this, propertyKey, val, style, priority);\n        },\n\n        get() {\n          return this[_propertyKey];\n        }\n\n      });\n    }\n  };\n}\n/**\n * Create a responsive style for component with a key\n * @param c The component\n * @param propertyKeyConfig Style key\n * @param value value\n * @param style style template\n * @param priority priority of style\n */\n\n\nfunction createStyle(c, propertyKeyConfig, value, style, priority) {\n  const propertyKey = typeof propertyKeyConfig === 'string' ? propertyKeyConfig : propertyKeyConfig.key;\n  const _propertyKeyClass = `_${propertyKey}Class`;\n  const _propertyKey = `_${propertyKey}Value`;\n  const oldValue = c[_propertyKey];\n  c[_propertyKey] = value;\n\n  if (value === null || value === undefined || value === false) {\n    // Remove classes\n    const classesForRemove = c[_propertyKeyClass];\n\n    if (classesForRemove && classesForRemove.length) {\n      classesForRemove.forEach(className => c.sRenderer.removeClass(className));\n    }\n  } else if (typeof value === 'string') {\n    if (oldValue !== value) {\n      c.sRenderer.removeClasses(c[_propertyKeyClass]);\n      const values = parseMediaQueriesFromString(value);\n\n      for (let index = 0; index < values.length; index++) {\n        const valAndMediaKey = values[index];\n        parseMediaQueryFromString(valAndMediaKey).forEach(_ => {\n          _renderStyle(c, propertyKeyConfig, _[0], _[1], style, priority);\n        });\n      }\n    }\n  } else if (typeof value === 'number' || value === true) {\n    if (oldValue !== value) {\n      c.sRenderer.removeClasses(c[_propertyKeyClass]);\n\n      _renderStyle(c, propertyKeyConfig, value, null, style, priority);\n    }\n  } else if (oldValue !== `${value}`) {\n    c.sRenderer.removeClasses(c[_propertyKeyClass]); // Is array\n\n    for (let index = 0; index < value.length; index++) {\n      const val = value[index];\n\n      if (typeof val === 'number' || val === null || val === undefined) {\n        _renderStyle(c, propertyKeyConfig, val, null, style, priority);\n      } else if (typeof val === 'string') {\n        parseMediaQueryFromString(val).forEach(_ => {\n          _renderStyle(c, propertyKeyConfig, _[0], _[1], style, priority);\n        });\n      }\n    }\n  }\n}\n\nfunction _renderStyle(c, propertyKeyConfig, val, media, style, priority) {\n  const propertyKey = typeof propertyKeyConfig === 'string' ? propertyKeyConfig : propertyKeyConfig.key;\n  const _propertyKeyClass = `_${propertyKey}Class`;\n  const styleTemplate = style(val, media, c);\n  const hasMedia = !!media;\n\n  if (styleTemplate == null) {\n    // Remove classes\n    const classesForRemove = c[_propertyKeyClass];\n\n    if (classesForRemove && classesForRemove.length) {\n      classesForRemove.forEach(className => c.sRenderer.removeClass(className));\n      c[_propertyKeyClass] = [];\n    }\n  } else {\n    if (c[_propertyKeyClass] === undefined) {\n      c[_propertyKeyClass] = [];\n    }\n\n    c[_propertyKeyClass].push(c.sRenderer.add(`${typeof propertyKeyConfig === 'string' ? getComponentName(c) : propertyKeyConfig.и}--${propertyKey}-${media ? val + '_' + media : val}`, styleTemplate, getComponentPriority(c, hasMedia ? 99999 : priority), c[_propertyKeyClass]));\n  }\n}\n\nfunction getComponentName(comp) {\n  return comp.constructor.и || comp.constructor.name || 'unnamed';\n}\n\nfunction getComponentPriority(comp, priority) {\n  var _a, _b;\n\n  return (_b = (_a = priority !== null && priority !== void 0 ? priority : comp.$priority) !== null && _a !== void 0 ? _a : comp.constructor.$priority) !== null && _b !== void 0 ? _b : 0;\n}\n\nconst STYLE_PRIORITY$1 = -0.5;\n/**\n * @dynamic\n */\n\nlet LyStyle = /*#__PURE__*/(() => {\n  class LyStyle {\n    constructor(sRenderer) {\n      this.sRenderer = sRenderer;\n    }\n\n    set size(value) {\n      this.width = value;\n      this.height = value;\n    }\n\n  }\n\n  /** @docs-private */\n  LyStyle.и = 'LyStyle';\n  LyStyle.$priority = STYLE_PRIORITY$1;\n\n  LyStyle.ɵfac = function LyStyle_Factory(t) {\n    return new (t || LyStyle)(i0.ɵɵdirectiveInject(StyleRenderer));\n  };\n\n  LyStyle.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LyStyle,\n    selectors: [[\"\", \"lyStyle\", \"\"], [\"\", \"lyColor\", \"\"], [\"\", \"lyBg\", \"\"], [\"\", \"lyP\", \"\"], [\"\", \"lyPf\", \"\"], [\"\", \"lyPe\", \"\"], [\"\", \"lyPt\", \"\"], [\"\", \"lyPb\", \"\"], [\"\", \"lyPx\", \"\"], [\"\", \"lyPy\", \"\"], [\"\", \"lyM\", \"\"], [\"\", \"lyMf\", \"\"], [\"\", \"lyMe\", \"\"], [\"\", \"lyMt\", \"\"], [\"\", \"lyMb\", \"\"], [\"\", \"lyMx\", \"\"], [\"\", \"lyMy\", \"\"], [\"\", \"lySize\", \"\"], [\"\", \"lyWidth\", \"\"], [\"\", \"lyMaxWidth\", \"\"], [\"\", \"lyMinWidth\", \"\"], [\"\", \"lyHeight\", \"\"], [\"\", \"lyMaxHeight\", \"\"], [\"\", \"lyMinHeight\", \"\"], [\"\", \"lyDisplay\", \"\"], [\"\", \"lyFlex\", \"\"], [\"\", \"lyFlexBasis\", \"\"], [\"\", \"lyFlexDirection\", \"\"], [\"\", \"lyFlexGrow\", \"\"], [\"\", \"lyFlexSelf\", \"\"], [\"\", \"lyFlexShrink\", \"\"], [\"\", \"lyFlexWrap\", \"\"], [\"\", \"lyJustifyContent\", \"\"], [\"\", \"lyJustifyItems\", \"\"], [\"\", \"lyJustifySelf\", \"\"], [\"\", \"lyAlignContent\", \"\"], [\"\", \"lyAlignItems\", \"\"], [\"\", \"lyOrder\", \"\"]],\n    inputs: {\n      lyStyle: \"lyStyle\",\n      color: [\"lyColor\", \"color\"],\n      bg: [\"lyBg\", \"bg\"],\n      p: [\"lyP\", \"p\"],\n      pf: [\"lyPf\", \"pf\"],\n      pe: [\"lyPe\", \"pe\"],\n      pt: [\"lyPt\", \"pt\"],\n      pb: [\"lyPb\", \"pb\"],\n      px: [\"lyPx\", \"px\"],\n      py: [\"lyPy\", \"py\"],\n      m: [\"lyM\", \"m\"],\n      mf: [\"lyMf\", \"mf\"],\n      me: [\"lyMe\", \"me\"],\n      mt: [\"lyMt\", \"mt\"],\n      mb: [\"lyMb\", \"mb\"],\n      mx: [\"lyMx\", \"mx\"],\n      my: [\"lyMy\", \"my\"],\n      size: [\"lySize\", \"size\"],\n      width: [\"lyWidth\", \"width\"],\n      maxWidth: [\"lyMaxWidth\", \"maxWidth\"],\n      minWidth: [\"lyMinWidth\", \"minWidth\"],\n      height: [\"lyHeight\", \"height\"],\n      maxHeight: [\"lyMaxHeight\", \"maxHeight\"],\n      minHeight: [\"lyMinHeight\", \"minHeight\"],\n      display: [\"lyDisplay\", \"display\"],\n      flex: [\"lyFlex\", \"flex\"],\n      flexBasis: [\"lyFlexBasis\", \"flexBasis\"],\n      flexDirection: [\"lyFlexDirection\", \"flexDirection\"],\n      flexGrow: [\"lyFlexGrow\", \"flexGrow\"],\n      flexSelf: [\"lyFlexSelf\", \"flexSelf\"],\n      flexShrink: [\"lyFlexShrink\", \"flexShrink\"],\n      flexWrap: [\"lyFlexWrap\", \"flexWrap\"],\n      justifyContent: [\"lyJustifyContent\", \"justifyContent\"],\n      justifyItems: [\"lyJustifyItems\", \"justifyItems\"],\n      justifySelf: [\"lyJustifySelf\", \"justifySelf\"],\n      alignContent: [\"lyAlignContent\", \"alignContent\"],\n      alignItems: [\"lyAlignItems\", \"alignItems\"],\n      order: [\"lyOrder\", \"order\"],\n      elevation: [\"lyElevation\", \"elevation\"]\n    },\n    features: [i0.ɵɵProvidersFeature([StyleRenderer])]\n  });\n\n  __decorate([Style(value => theme => _className => `${_className}{color:${theme.colorOf(value)};}`)], LyStyle.prototype, \"color\", void 0);\n\n  __decorate([Style(value => theme => _className => `${_className}{background:${theme.colorOf(value)};}`)], LyStyle.prototype, \"bg\", void 0);\n\n  __decorate([Style((value, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{padding:${to8Px(value)};}}`)], LyStyle.prototype, \"p\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints,\n    after\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{padding-${after}:${to8Px(val)};}}`)], LyStyle.prototype, \"pf\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints,\n    before\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{padding-${before}:${to8Px(val)};}}`)], LyStyle.prototype, \"pe\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{padding-top:${to8Px(val)};}}`)], LyStyle.prototype, \"pt\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{padding-bottom:${to8Px(val)};}}`)], LyStyle.prototype, \"pb\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{padding:0 ${to8Px(val)};}}`)], LyStyle.prototype, \"px\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{padding:${to8Px(val)} 0;}}`)], LyStyle.prototype, \"py\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{margin:${to8Px(val)};}}`)], LyStyle.prototype, \"m\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints,\n    after\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{margin-${after}:${to8Px(val)};}}`)], LyStyle.prototype, \"mf\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints,\n    before\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{margin-${before}:${to8Px(val)};}}`)], LyStyle.prototype, \"me\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{margin-top:${to8Px(val)};}}`)], LyStyle.prototype, \"mt\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{margin-bottom:${to8Px(val)};}}`)], LyStyle.prototype, \"mb\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{margin:0 ${to8Px(val)};}}`)], LyStyle.prototype, \"mx\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{margin:${to8Px(val)} 0;}}`)], LyStyle.prototype, \"my\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{width:${transform(val)};}}`)], LyStyle.prototype, \"width\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{max-width:${transform(val)};}}`)], LyStyle.prototype, \"maxWidth\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{min-width:${transform(val)};}}`)], LyStyle.prototype, \"minWidth\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{height:${transform(val)};}}`)], LyStyle.prototype, \"height\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{max-height:${transform(val)};}}`)], LyStyle.prototype, \"maxHeight\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{min-height:${transform(val)};}}`)], LyStyle.prototype, \"minHeight\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{display:${val};}}`)], LyStyle.prototype, \"display\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{flex:${val};}}`)], LyStyle.prototype, \"flex\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{flex-basis:${val};}}`)], LyStyle.prototype, \"flexBasis\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{flex-direction:${val};}}`)], LyStyle.prototype, \"flexDirection\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{flex-grow:${val};}}`)], LyStyle.prototype, \"flexGrow\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{flex-self:${val};}}`)], LyStyle.prototype, \"flexSelf\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{flex-shrink:${val};}}`)], LyStyle.prototype, \"flexShrink\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{flex-wrap:${val};}}`)], LyStyle.prototype, \"flexWrap\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{justify-content:${val};}}`)], LyStyle.prototype, \"justifyContent\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{justify-items:${val};}}`)], LyStyle.prototype, \"justifyItems\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{justify-self:${val};}}`)], LyStyle.prototype, \"justifySelf\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{align-content:${val};}}`)], LyStyle.prototype, \"alignContent\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{align-items:${val};}}`)], LyStyle.prototype, \"alignItems\", void 0);\n\n  __decorate([Style((val, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && breakpoints[media] || 'all'}{${_className}{order:${val};}}`)], LyStyle.prototype, \"order\", void 0);\n\n  __decorate([Style((value, media) => ({\n    breakpoints\n  }) => _className => `@media ${media && (breakpoints[media] || media) || 'all'}{${_className}{${value};}}`)], LyStyle.prototype, \"lyStyle\", void 0);\n\n  __decorate([Style2((value, media) => ({\n    breakpoints,\n    shadow\n  }) => _className => `@media ${media && (breakpoints[media] || media) || 'all'}{${_className}{box-shadow:${shadowBuilder(value, shadow)};}}`, coerceNumberProperty)], LyStyle.prototype, \"elevation\", void 0);\n\n  return LyStyle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @dynamic\n * @deprecated\n * Spacing\n * [p], [pf], [pe], [pt], [pb], [px], [py],\n * [m], [mf], [me], [mt], [mb], [mx], [my],\n * Sizing\n * [size],\n * [width], [maxWidth], [minWidth],\n * [height], [maxHeight], [minHeight],\n * Others\n * [lyStyle]\n */\n\n\nlet LyStyleDeprecated = /*#__PURE__*/(() => {\n  class LyStyleDeprecated extends LyStyle {\n    constructor(sRenderer, _el) {\n      super(sRenderer);\n      this._el = _el;\n    }\n\n    ngOnChanges(changes) {\n      if (isDevMode()) {\n        for (const key in changes) {\n          if (changes.hasOwnProperty(key)) {\n            const message = `[${key}] is deprecated, use [ly${key.charAt(0).toUpperCase() + key.slice(1)}] instead.`;\n            console.warn({\n              message,\n              element: this._el.nativeElement\n            });\n          }\n        }\n      }\n    }\n\n  }\n\n  LyStyleDeprecated.ɵfac = function LyStyleDeprecated_Factory(t) {\n    return new (t || LyStyleDeprecated)(i0.ɵɵdirectiveInject(StyleRenderer), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  LyStyleDeprecated.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LyStyleDeprecated,\n    selectors: [[\"\", \"p\", \"\"], [\"\", \"pf\", \"\"], [\"\", \"pe\", \"\"], [\"\", \"pt\", \"\"], [\"\", \"pb\", \"\"], [\"\", \"px\", \"\"], [\"\", \"py\", \"\"], [\"\", \"m\", \"\"], [\"\", \"mf\", \"\"], [\"\", \"me\", \"\"], [\"\", \"mt\", \"\"], [\"\", \"mb\", \"\"], [\"\", \"mx\", \"\"], [\"\", \"my\", \"\"], [\"\", \"size\", \"\", 3, \"ly-button\", \"\"], [\"\", \"width\", \"\", 5, \"svg\", 5, \"canvas\", 5, \"embed\", 5, \"iframe\", 5, \"img\", 5, \"input\", 5, \"object\", 5, \"video\"], [\"\", \"maxWidth\", \"\"], [\"\", \"minWidth\", \"\"], [\"\", \"height\", \"\", 5, \"svg\", 5, \"canvas\", 5, \"embed\", 5, \"iframe\", 5, \"img\", 5, \"input\", 5, \"object\", 5, \"video\"], [\"\", \"maxHeight\", \"\"], [\"\", \"minHeight\", \"\"], [\"\", \"display\", \"\"], [\"\", \"flex\", \"\"], [\"\", \"flexBasis\", \"\"], [\"\", \"flexDirection\", \"\"], [\"\", \"flexGrow\", \"\"], [\"\", \"flexSelf\", \"\"], [\"\", \"flexShrink\", \"\"], [\"\", \"flexWrap\", \"\"], [\"\", \"justifyContent\", \"\"], [\"\", \"justifyItems\", \"\"], [\"\", \"justifySelf\", \"\"], [\"\", \"alignContent\", \"\"], [\"\", \"alignItems\", \"\"], [\"\", \"order\", \"\"]],\n    inputs: {\n      p: \"p\",\n      pf: \"pf\",\n      pe: \"pe\",\n      pt: \"pt\",\n      pb: \"pb\",\n      px: \"px\",\n      py: \"py\",\n      m: \"m\",\n      mf: \"mf\",\n      me: \"me\",\n      mt: \"mt\",\n      mb: \"mb\",\n      mx: \"mx\",\n      my: \"my\",\n      size: \"size\",\n      width: \"width\",\n      maxWidth: \"maxWidth\",\n      minWidth: \"minWidth\",\n      height: \"height\",\n      maxHeight: \"maxHeight\",\n      minHeight: \"minHeight\",\n      display: \"display\",\n      flex: \"flex\",\n      flexBasis: \"flexBasis\",\n      flexDirection: \"flexDirection\",\n      flexGrow: \"flexGrow\",\n      flexSelf: \"flexSelf\",\n      flexShrink: \"flexShrink\",\n      flexWrap: \"flexWrap\",\n      justifyContent: \"justifyContent\",\n      justifyItems: \"justifyItems\",\n      justifySelf: \"justifySelf\",\n      alignContent: \"alignContent\",\n      alignItems: \"alignItems\",\n      order: \"order\"\n    },\n    features: [i0.ɵɵProvidersFeature([StyleRenderer]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return LyStyleDeprecated;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Convert to px if the value is a number, otherwise leave it as is\n * @docs-private\n */\n\n\nfunction to8Px(val) {\n  return typeof val === 'number' ? `${val * 8}px` : val.includes(' ') ? val.split(' ').map(_ => strTo8Px(_)).join(' ') : strTo8Px(val);\n}\n\nfunction strTo8Px(val) {\n  const num = +val;\n  return isNaN(num) ? val : `${num * 8}px`;\n}\n\nfunction strToPx(val) {\n  const num = +val;\n  return isNaN(num) ? val : `${num}px`;\n}\n\nfunction transform(value) {\n  return value <= 1 ? `${value * 100}%` : typeof value === 'number' ? `${value}px` : value.includes(' ') ? value.split(' ').map(_ => strToPx(_)).join(' ') : strToPx(value);\n}\n\nlet LyCommonModule = /*#__PURE__*/(() => {\n  class LyCommonModule {}\n\n  LyCommonModule.ɵfac = function LyCommonModule_Factory(t) {\n    return new (t || LyCommonModule)();\n  };\n\n  LyCommonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LyCommonModule\n  });\n  LyCommonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return LyCommonModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @deprecated\n */\n\n\nlet LyStyleDeprecatedModule = /*#__PURE__*/(() => {\n  class LyStyleDeprecatedModule {}\n\n  LyStyleDeprecatedModule.ɵfac = function LyStyleDeprecatedModule_Factory(t) {\n    return new (t || LyStyleDeprecatedModule)();\n  };\n\n  LyStyleDeprecatedModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LyStyleDeprecatedModule\n  });\n  LyStyleDeprecatedModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return LyStyleDeprecatedModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction defaultEntry(value, defaultValue) {\n  return value !== '' && value !== void 0 ? value : defaultValue;\n}\n/**\n * @experimental\n * Element to move, time in ms to animate\n */\n\n\nfunction scrollTo(element, duration) {\n  let e = document.documentElement;\n\n  if (e.scrollTop === 0) {\n    const t = e.scrollTop;\n    ++e.scrollTop;\n    e = t + 1 === e.scrollTop-- ? e : document.body;\n  }\n\n  scrollToFromTo(e, e.scrollTop, element, duration);\n} // Element to move, element or px from, element or px to, time in ms to animate\n\n\nfunction scrollToFromTo(element, from, to, duration) {\n  if (duration <= 0) {\n    return;\n  }\n\n  if (typeof from === 'object') {\n    from = from.offsetTop;\n  }\n\n  if (typeof to === 'object') {\n    to = to.offsetTop;\n  }\n\n  createScrollWithAnimation(element, from, to, 0, 1 / duration, 20, easeOutCuaic);\n}\n/**\n * @experimental\n */\n\n\nfunction scrollWithAnimation(element, to, duration, p, motion) {\n  const _motion = motion || easeOutCuaic;\n\n  const {\n    scrollLeft\n  } = element;\n  return createScrollWithAnimation(element, scrollLeft, to, 0, 1 / duration, 20, _motion, p);\n}\n\nfunction createScrollWithAnimation(element, xFrom, xTo, t01, speed, step, motion, p) {\n  const scrollT = p === 'y' ? 'scrollTop' : 'scrollLeft';\n\n  if (t01 < 0 || t01 > 1 || speed <= 0) {\n    element[scrollT] = xTo;\n    return;\n  }\n\n  element[scrollT] = xFrom - (xFrom - xTo) * motion(t01);\n  t01 += speed * step;\n  setTimeout(() => {\n    createScrollWithAnimation(element, xFrom, xTo, t01, speed, step, motion, p);\n  }, step);\n} // function linearTween(t: number) {\n//   return t;\n// }\n// function easeInQuad(t: number) {\n//   return t * t;\n// }\n// function easeOutQuad(t: number) {\n//   return -t * (t - 2);\n// }\n// function easeInOutQuad(t: number) {\n//   t /= 0.5;\n//   if (t < 1) {return t * t / 2; }\n//   t--;\n//   return (t * (t - 2) - 1) / 2;\n// }\n// function easeInCuaic(t: number) {\n//   return t * t * t;\n// }\n\n\nfunction easeOutCuaic(t) {\n  t--;\n  return t * t * t + 1;\n} // function easeInOutCuaic(t: number) {\n//   t /= 0.5;\n//   if (t < 1) {return t * t * t / 2; }\n//   t -= 2;\n//   return (t * t * t + 2) / 2;\n// }\n// function easeInQuart(t: number) {\n//   return t * t * t * t;\n// }\n// function easeOutQuart(t: number) {\n//   t--;\n//   return -(t * t * t * t - 1);\n// }\n// function easeInOutQuart(t: number) {\n//   t /= 0.5;\n//   if (t < 1) {return 0.5 * t * t * t * t; }\n//   t -= 2;\n//   return -(t * t * t * t - 2) / 2;\n// }\n// function easeInQuint(t: number) {\n//   return t * t * t * t * t;\n// }\n// function easeOutQuint(t: number) {\n//   t--;\n//   return t * t * t * t * t + 1;\n// }\n// function easeInOutQuint(t: number) {\n//   t /= 0.5;\n//   if (t < 1) {return t * t * t * t * t / 2; }\n//   t -= 2;\n//   return (t * t * t * t * t + 2) / 2;\n// }\n// function easeInSine(t: number) {\n//   return -Math.cos(t / (Math.PI / 2)) + 1;\n// }\n// function easeOutSine(t: number) {\n//   return Math.sin(t / (Math.PI / 2));\n// }\n// function easeInOutSine(t: number) {\n//   return -(Math.cos(Math.PI * t) - 1) / 2;\n// }\n// function easeInExpo(t: number) {\n//   return Math.pow(2, 10 * (t - 1));\n// }\n// function easeOutExpo(t: number) {\n//   return -Math.pow(2, -10 * t) + 1;\n// }\n// function easeInOutExpo(t: number) {\n//   t /= 0.5;\n//   if (t < 1) {return Math.pow(2, 10 * (t - 1)) / 2; }\n//   t--;\n//   return (-Math.pow(2, -10 * t) + 2) / 2;\n// }\n// function easeInCirc(t: number) {\n//   return -Math.sqrt(1 - t * t) - 1;\n// }\n// function easeOutCirc(t: number) {\n//   t--;\n//   return Math.sqrt(1 - t * t);\n// }\n// function easeInOutCirc(t: number) {\n//   t /= 0.5;\n//   if (t < 1) {return -(Math.sqrt(1 - t * t) - 1) / 2; }\n//   t -= 2;\n//   return (Math.sqrt(1 - t * t) + 1) / 2;\n// }\n\n\nfunction toNumber(val, _default) {\n  const num = typeof val === 'number' ? val : typeof val === 'string' && val.length ? +val : _default;\n  return isNaN(num) ? _default === void 0 ? 0 : _default : num;\n}\n\nfunction componentDestroyed(component) {\n  const modifiedComponent = component;\n\n  if (modifiedComponent.__componentDestroyed$) {\n    return modifiedComponent.__componentDestroyed$;\n  }\n\n  const oldNgOnDestroy = component.ngOnDestroy;\n  const stop$ = new ReplaySubject();\n\n  modifiedComponent.ngOnDestroy = function () {\n    if (oldNgOnDestroy) {\n      oldNgOnDestroy.apply(component);\n    }\n\n    stop$.next();\n    stop$.complete();\n  };\n\n  return modifiedComponent.__componentDestroyed$ = stop$.asObservable();\n}\n\nfunction untilComponentDestroyed(component) {\n  return source => source.pipe(takeUntil(componentDestroyed(component)));\n}\n\nlet LyHostClass = /*#__PURE__*/(() => {\n  class LyHostClass {\n    constructor(_el, _renderer) {\n      this._renderer = _renderer;\n      this._set = new Set();\n      this._nEl = _el.nativeElement;\n      console.log(`LyHostClass: Deprecated use instead StyleRenderer`);\n    }\n\n    add(className) {\n      if (!this._set.has(className)) {\n        this._set.add(className);\n\n        this._renderer.addClass(this._nEl, className);\n      }\n    }\n\n    remove(className) {\n      if (className && this._set.has(className)) {\n        this._set.delete(className);\n\n        this._renderer.removeClass(this._nEl, className);\n      }\n    }\n\n    toggle(className, enabled) {\n      if (enabled) {\n        this.add(className);\n      } else {\n        this.remove(className);\n      }\n    }\n\n    update(newClassName, oldClassName) {\n      this.remove(oldClassName);\n      this.add(newClassName);\n      return newClassName;\n    }\n\n  }\n\n  LyHostClass.ɵfac = function LyHostClass_Factory(t) {\n    return new (t || LyHostClass)(i0.ɵɵinject(i0.ElementRef), i0.ɵɵinject(i0.Renderer2));\n  };\n\n  LyHostClass.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LyHostClass,\n    factory: LyHostClass.ɵfac\n  });\n  return LyHostClass;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar FocusStatus = /*#__PURE__*/(() => {\n  (function (FocusStatus) {\n    /**mouse and/or touch*/\n    FocusStatus[\"DEFAULT\"] = \"default\";\n    /** keyboard and/or program*/\n\n    FocusStatus[\"KEYBOARD\"] = \"keyboard\";\n  })(FocusStatus || (FocusStatus = {}));\n\n  return FocusStatus;\n})();\nlet LyFocusState = /*#__PURE__*/(() => {\n  class LyFocusState {\n    constructor(_ngZone, _platform) {\n      this._ngZone = _ngZone;\n      this._platform = _platform;\n      this._elementMap = new Map();\n      this._count = 0;\n    }\n\n    listen(element, keyElement) {\n      if (!this._platform.isBrowser) {\n        // return null if it is not browser platform\n        return null;\n      }\n\n      const nativeElement = getNativeElement(element);\n      const key = keyElement && getNativeElement(keyElement) || nativeElement;\n\n      if (this._elementMap.has(key)) {\n        return this._elementMap.get(key).subject.asObservable();\n      }\n\n      const focusState = {\n        unlisten: null,\n        subject: new Subject()\n      };\n\n      this._incrementCount();\n\n      const focusListener = event => this._on(event, focusState.subject);\n\n      const blurListener = event => this._on(event, focusState.subject);\n\n      focusState.unlisten = () => {\n        nativeElement.removeEventListener('focus', focusListener, true);\n        nativeElement.removeEventListener('blur', blurListener, true);\n      };\n\n      this._elementMap.set(key, focusState);\n\n      this._ngZone.runOutsideAngular(() => {\n        nativeElement.addEventListener('focus', focusListener, true);\n        nativeElement.addEventListener('blur', blurListener, true);\n      });\n\n      return focusState.subject.asObservable();\n    }\n\n    focusElement(element, origin, options) {\n      const nativeElement = getNativeElement(element);\n      this._currentEvent = origin;\n\n      if (typeof nativeElement.focus === 'function') {\n        nativeElement.focus(options);\n      }\n    }\n\n    unlisten(element) {\n      if (!this._platform.isBrowser) {\n        return;\n      }\n\n      const el = getNativeElement(element);\n\n      const focusStateInfo = this._elementMap.get(el);\n\n      if (focusStateInfo) {\n        focusStateInfo.unlisten();\n\n        this._elementMap.delete(el);\n\n        this._decrementCount();\n      }\n    }\n\n    _on(event, subject) {\n      let by = null;\n\n      if (event.type === 'focus') {\n        by = this._currentEvent || 'keyboard';\n      }\n\n      this._ngZone.run(() => subject.next(by));\n    }\n\n    _addGlobalListeners() {\n      if (!this._platform.isBrowser) {\n        return;\n      }\n\n      const eventListenerOptions = supportsPassiveEventListeners() ? {\n        passive: true,\n        capture: true\n      } : false;\n\n      const documentKeydownListener = () => this._ngZone.runOutsideAngular(() => this._currentEvent = 'keyboard');\n\n      const documentMousedownListener = () => this._ngZone.runOutsideAngular(() => this._currentEvent = 'mouse');\n\n      this._ngZone.runOutsideAngular(() => {\n        document.addEventListener('keydown', documentKeydownListener, eventListenerOptions);\n        document.addEventListener('mousedown', documentMousedownListener, eventListenerOptions);\n      });\n\n      this._removeGlobalListeners = () => {\n        document.removeEventListener('keydown', documentKeydownListener, eventListenerOptions);\n        document.removeEventListener('mousedown', documentMousedownListener, eventListenerOptions);\n      };\n    }\n\n    _incrementCount() {\n      if (++this._count === 1) {\n        this._addGlobalListeners();\n      }\n    }\n\n    _decrementCount() {\n      if (! --this._count) {\n        this._removeGlobalListeners();\n      }\n    }\n\n    ngOnDestroy() {\n      this._elementMap.forEach((_, element) => this.unlisten(element));\n    }\n\n  }\n\n  LyFocusState.ɵfac = function LyFocusState_Factory(t) {\n    return new (t || LyFocusState)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.Platform));\n  };\n\n  LyFocusState.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LyFocusState,\n    factory: LyFocusState.ɵfac,\n    providedIn: 'root'\n  });\n  return LyFocusState;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst AUI_VERSION = '13.2.2';\nconst AUI_LAST_UPDATE = '2022-07-19T00:04:39.136Z';\nconst LY_HAMMER_OPTIONS = new InjectionToken('LY_HAMMER_OPTIONS');\nconst HAMMER_GESTURES_EVENTS = ['slide', 'slidestart', 'slideend', 'slideright', 'slideleft', 'slidecancel'];\n/**\n * Fake HammerInstance that is used when a Hammer instance is requested when HammerJS has not\n * been loaded on the page.\n */\n\nconst noopHammerInstance = {\n  on: () => {},\n  off: () => {}\n};\nlet LyHammerGestureConfig = /*#__PURE__*/(() => {\n  class LyHammerGestureConfig extends HammerGestureConfig {\n    constructor(_hammerOptions) {\n      super();\n      this._hammerOptions = _hammerOptions;\n      this.events = HAMMER_GESTURES_EVENTS;\n    }\n\n    buildHammer(element) {\n      const hammer = typeof window !== 'undefined' ? window.Hammer : null;\n\n      if (!hammer) {\n        return noopHammerInstance;\n      }\n\n      const mc = new hammer(element, this._hammerOptions || {});\n      const pan = new hammer.Pan();\n      const swipe = new hammer.Swipe();\n\n      const slide = this._createRecognizer(pan, {\n        event: 'slide',\n        threshold: 0\n      }, swipe);\n\n      pan.recognizeWith(swipe); // Add customized gestures to Hammer manager\n\n      mc.add([swipe, pan, slide]);\n      return mc;\n    }\n    /** Creates a new recognizer, without affecting the default recognizers of HammerJS */\n\n\n    _createRecognizer(base, options, ...inheritances) {\n      const recognizer = new base.constructor(options);\n      inheritances.push(base);\n      inheritances.forEach(item => recognizer.recognizeWith(item));\n      return recognizer;\n    }\n\n  }\n\n  LyHammerGestureConfig.ɵfac = function LyHammerGestureConfig_Factory(t) {\n    return new (t || LyHammerGestureConfig)(i0.ɵɵinject(LY_HAMMER_OPTIONS, 8));\n  };\n\n  LyHammerGestureConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LyHammerGestureConfig,\n    factory: LyHammerGestureConfig.ɵfac\n  });\n  return LyHammerGestureConfig;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LyThemeModule = /*#__PURE__*/(() => {\n  class LyThemeModule {\n    static setTheme(themeName) {\n      return {\n        ngModule: LyThemeModule,\n        providers: [[LyTheme2], [StyleRenderer], {\n          provide: LY_THEME_NAME,\n          useValue: themeName\n        }]\n      };\n    }\n\n  }\n\n  LyThemeModule.ɵfac = function LyThemeModule_Factory(t) {\n    return new (t || LyThemeModule)();\n  };\n\n  LyThemeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LyThemeModule\n  });\n  LyThemeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return LyThemeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass Undefined {\n  constructor() {}\n\n}\n\nconst UndefinedValue = new Undefined(); // @Injectable()\n\nclass LyOverlayRef {}\n\nconst styles = theme => {\n  return {\n    overlay: _className => `${_className}{position:fixed;top:0;left:0;right:0;bottom:0;z-index:${theme.zIndex.overlay};pointer-events:none;}`\n  };\n};\n\nlet LyOverlayContainer = /*#__PURE__*/(() => {\n  class LyOverlayContainer {\n    constructor(theme, _platform, _ngZone, document) {\n      this.theme = theme;\n      this._platform = _platform;\n      this._ngZone = _ngZone;\n      this._classes = this.theme.addStyleSheet(styles);\n      this._items = new Set();\n      this._overlays = new Set();\n      /** Keyboard event listener that will be attached to the body. */\n\n      this._keydownListener = event => {\n        const overlays = Array.from(this._overlays);\n\n        for (let i = overlays.length - 1; i > -1; i--) {\n          const observed = overlays[i]._keydownEvents.observers.length > 0;\n\n          if (observed) {\n            const keydownEvents = overlays[i]._keydownEvents;\n\n            this._ngZone.run(() => keydownEvents.next(event));\n\n            break;\n          }\n        }\n      };\n\n      this._document = document;\n\n      if (this._platform.isBrowser) {\n        const container = document.createElement('ly-overlay-container');\n        document.body.appendChild(container);\n        this._containerElement = container;\n      }\n    }\n\n    get overlayLen() {\n      return this._items.size;\n    }\n\n    get containerElement() {\n      return this._containerElement;\n    }\n\n    addOverlay(overlayRef) {\n      this._overlays.add(overlayRef);\n\n      if (!this._isAttached) {\n        this._ngZone.runOutsideAngular(() => this._document.body.addEventListener('keydown', this._keydownListener));\n\n        this._isAttached = true;\n      }\n    }\n\n    removeOverlay(overlayRef) {\n      this._overlays.delete(overlayRef);\n\n      if (!this._overlays.size && this._isAttached) {\n        this._document.body.removeEventListener('keydown', this._keydownListener);\n\n        this._isAttached = false;\n      }\n    }\n    /**\n     * Add instance\n     * @ignore\n     */\n\n\n    _addElement(item) {\n      this._items.add(item);\n\n      this.containerElement.appendChild(item);\n\n      this._update();\n    }\n    /**\n    * Remove instance\n    * @ignore\n    */\n\n\n    _removeElement(item) {\n      this.containerElement.removeChild(item);\n\n      this._items.delete(item);\n\n      this._update();\n    }\n    /**\n     * Update styles for overlay container\n     * @ignore\n     */\n\n\n    _update() {\n      if (this._items.size) {\n        if (!this._isActiveOverlayContainer) {\n          this._isActiveOverlayContainer = true;\n\n          this._containerElement.classList.add(this._classes.overlay);\n        }\n      } else if (this._isActiveOverlayContainer) {\n        this._containerElement.classList.remove(this._classes.overlay);\n\n        this._isActiveOverlayContainer = false;\n      }\n    }\n\n  }\n\n  LyOverlayContainer.ɵfac = function LyOverlayContainer_Factory(t) {\n    return new (t || LyOverlayContainer)(i0.ɵɵinject(LyTheme2), i0.ɵɵinject(i1.Platform), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DOCUMENT));\n  };\n\n  LyOverlayContainer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LyOverlayContainer,\n    factory: LyOverlayContainer.ɵfac,\n    providedIn: 'root'\n  });\n  return LyOverlayContainer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass LyOverlayConfig {\n  constructor() {\n    this.hasBackdrop = true;\n    /**\n     * Whether the user can click on the backdrop to close the overlay.\n     */\n\n    this.disableClose = false;\n  }\n\n}\n\nconst STYLE_PRIORITY = -2;\n\nconst STYLES_BACKDROP_ROOT = () => _className => `${st2c(LY_COMMON_STYLES.fill, `${_className}`)}${_className}{width:100vw;height:100vh;pointer-events:all;user-select:none;}`;\n\nlet LyOverlayBackdrop = /*#__PURE__*/(() => {\n  class LyOverlayBackdrop {\n    constructor(_el, _theme, sRenderer, _config) {\n      this._el = _el;\n      this.sRenderer = sRenderer;\n      this._config = _config;\n\n      _el.nativeElement.classList.add(sRenderer.add(STYLES_BACKDROP_ROOT, STYLE_PRIORITY)); // this applies custom class for backdrop,\n      // if one is not defined, do nothing.\n\n\n      const backdropClass = _config.backdropClass;\n\n      if (backdropClass) {\n        this._el.nativeElement.classList.add(backdropClass);\n      }\n    }\n\n    onclick() {\n      if (!this._config.disableClose) {\n        this._config.fnDestroy();\n      }\n    }\n\n  }\n\n  LyOverlayBackdrop.ɵfac = function LyOverlayBackdrop_Factory(t) {\n    return new (t || LyOverlayBackdrop)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(LyTheme2), i0.ɵɵdirectiveInject(StyleRenderer), i0.ɵɵdirectiveInject(LyOverlayConfig));\n  };\n\n  LyOverlayBackdrop.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: LyOverlayBackdrop,\n    selectors: [[\"ly-overlay-backdrop\"]],\n    hostBindings: function LyOverlayBackdrop_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function LyOverlayBackdrop_click_HostBindingHandler() {\n          return ctx.onclick();\n        });\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([StyleRenderer])],\n    decls: 0,\n    vars: 0,\n    template: function LyOverlayBackdrop_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return LyOverlayBackdrop;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction createOverlayInjector(parent, config, overlayFactory) {\n  return Injector.create({\n    providers: [{\n      provide: LyOverlayConfig,\n      useValue: config\n    }, {\n      provide: LyOverlayRef,\n      useValue: overlayFactory\n    }],\n    parent\n  });\n}\n\nclass OverlayFactory {\n  constructor(_componentFactoryResolver, _appRef, _templateRefOrComponent, _overlayContainer, _context, _injector, _scrollDispatcher, _viewportRuler, _config) {\n    this._componentFactoryResolver = _componentFactoryResolver;\n    this._appRef = _appRef;\n    this._overlayContainer = _overlayContainer;\n    this._injector = _injector;\n    /** Stream of keydown events dispatched to this overlay. */\n\n    this._keydownEvents = new Subject();\n    this._windowSRSub = Subscription.EMPTY;\n    this._isDetached = false;\n    this._isRemoved = false;\n    const config = Object.assign(Object.assign({}, new LyOverlayConfig()), _config);\n    this._el = document.createElement('div');\n    const __styles = {\n      position: 'absolute',\n      display: 'flex',\n      justifyContent: 'center',\n      alignItems: 'center',\n      pointerEvents: 'none'\n    };\n\n    if (config) {\n      Object.assign(__styles, config.styles);\n    }\n\n    const newInjector = this._newInjector = createOverlayInjector(config.injector || this._injector, Object.assign(Object.assign({\n      fnDestroy: this.destroy.bind(this)\n    }, config), {\n      styles: __styles\n    }), this);\n\n    this._updateStyles(__styles);\n\n    if (config) {\n      if (config.onResizeScroll) {\n        this.onResizeScroll = config.onResizeScroll;\n      }\n\n      this._windowSRSub = merge(_scrollDispatcher.scrolled(0), _viewportRuler.change()).subscribe(() => {\n        if (this.onResizeScroll) {\n          this.onResizeScroll();\n        }\n      });\n\n      if (config.classes) {\n        const classes = config.classes;\n        classes.forEach(className => this._el.classList.add(className));\n      }\n    }\n\n    this.updateBackdrop(!!config.hasBackdrop);\n\n    this._appendComponentToBody(_templateRefOrComponent, _context, newInjector);\n\n    this._updateBackdropPosition();\n  }\n\n  get injector() {\n    return this._newInjector;\n  }\n\n  get containerElement() {\n    return this._el;\n  }\n\n  get backdropElement() {\n    return this._backdropElement;\n  }\n\n  get componentRef() {\n    return this._compRef;\n  }\n\n  get isDestroyed() {\n    return this._isRemoved;\n  }\n\n  updateBackdrop(hasBackdrop) {\n    if (hasBackdrop) {\n      if (this._compRefOverlayBackdrop) {\n        return;\n      }\n\n      this._compRefOverlayBackdrop = this._generateComponent(LyOverlayBackdrop, this._newInjector);\n\n      this._appRef.attachView(this._compRefOverlayBackdrop.hostView);\n\n      this._backdropElement = this._compRefOverlayBackdrop.location.nativeElement;\n\n      this._overlayContainer._addElement(this._backdropElement);\n    } else if (this._compRefOverlayBackdrop) {\n      this._appRef.detachView(this._compRefOverlayBackdrop.hostView);\n\n      this._backdropElement = this._compRefOverlayBackdrop.location.nativeElement;\n\n      this._overlayContainer._removeElement(this._backdropElement);\n\n      this._compRefOverlayBackdrop = null;\n    }\n\n    this._updateBackdropPosition();\n  }\n  /** Gets an observable of keydown events targeted to this overlay. */\n\n\n  keydownEvents() {\n    return this._keydownEvents;\n  }\n\n  _updateStyles(__styles) {\n    /** Apply styles */\n\n    /** set styles */\n    for (const key in __styles) {\n      if (__styles.hasOwnProperty(key)) {\n        const styleVal = __styles[key];\n\n        if (styleVal != null) {\n          this._el.style[key] = typeof __styles[key] === 'number' ? `${styleVal}px` : styleVal;\n        }\n      }\n    }\n  }\n\n  _appendComponentToBody(type, context, injector) {\n    if (type instanceof TemplateRef) {\n      // Create a component reference from the component\n      const viewRef = this._viewRef = type.createEmbeddedView(context || {});\n\n      this._appRef.attachView(viewRef); // Get DOM element from component\n\n\n      viewRef.rootNodes.forEach(_ => this._el.appendChild(_)); // Append DOM element to the body\n\n      this._overlayContainer._addElement(this._el);\n    } else if (typeof type === 'string') {\n      this._el.innerText = type;\n\n      this._overlayContainer._addElement(this._el);\n    } else {\n      this._compRef = this._generateComponent(type, injector);\n\n      this._appRef.attachView(this._compRef.hostView);\n\n      this._el.appendChild(this._compRef.location.nativeElement);\n\n      this._overlayContainer._addElement(this._el);\n    }\n\n    this._overlayContainer.addOverlay(this);\n  }\n\n  _updateBackdropPosition() {\n    var _a, _b;\n\n    const container = this._overlayContainer.containerElement;\n\n    if (((_a = this._backdropElement) === null || _a === void 0 ? void 0 : _a.parentElement) === container && ((_b = this._el) === null || _b === void 0 ? void 0 : _b.parentElement) === container) {\n      this._overlayContainer.containerElement.insertBefore(this._backdropElement, this._el);\n    }\n  }\n\n  _generateComponent(type, injector) {\n    const factory = this._componentFactoryResolver.resolveComponentFactory(type);\n\n    return factory.create(injector);\n  }\n  /** Detaches a view from dirty checking again of ApplicationRef. */\n\n\n  detach() {\n    if (this._isDetached) {\n      return;\n    }\n\n    this._isDetached = true;\n\n    if (this._viewRef) {\n      this._appRef.detachView(this._viewRef);\n    }\n\n    if (this._compRef) {\n      this._appRef.detachView(this._compRef.hostView);\n    }\n\n    this._overlayContainer.removeOverlay(this);\n\n    this._keydownEvents.complete();\n  }\n  /** Remove element of DOM */\n\n\n  remove() {\n    if (this._isRemoved) {\n      return;\n    }\n\n    this._isRemoved = true;\n\n    if (this._viewRef) {\n      this._viewRef.destroy();\n\n      this._overlayContainer._removeElement(this._el);\n\n      this._el = null;\n      this._viewRef = null;\n    } else if (this._compRef) {\n      this._compRef.destroy();\n\n      this._overlayContainer._removeElement(this._el);\n\n      this._el = null;\n      this._compRef = null;\n    } else if (this._el) {\n      // remove if template is string\n      this._overlayContainer._removeElement(this._el);\n\n      this._el = null;\n    }\n\n    this.updateBackdrop(false);\n\n    this._windowSRSub.unsubscribe();\n  }\n  /** Detach & remove */\n\n\n  destroy() {\n    this.detach();\n    this.remove();\n  }\n\n}\n\nlet LyOverlay = /*#__PURE__*/(() => {\n  class LyOverlay {\n    constructor(_overlayContainer, _componentFactoryResolver, _appRef, _injector, _scrollDispatcher, _viewportRuler) {\n      this._overlayContainer = _overlayContainer;\n      this._componentFactoryResolver = _componentFactoryResolver;\n      this._appRef = _appRef;\n      this._injector = _injector;\n      this._scrollDispatcher = _scrollDispatcher;\n      this._viewportRuler = _viewportRuler;\n    }\n\n    create(templateOrComponent, context, config) {\n      return new OverlayFactory(this._componentFactoryResolver, this._appRef, templateOrComponent, this._overlayContainer, context, this._injector, this._scrollDispatcher, this._viewportRuler, config);\n    }\n\n  }\n\n  LyOverlay.ɵfac = function LyOverlay_Factory(t) {\n    return new (t || LyOverlay)(i0.ɵɵinject(LyOverlayContainer), i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.ApplicationRef), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i2.ScrollDispatcher), i0.ɵɵinject(i2.ViewportRuler));\n  };\n\n  LyOverlay.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LyOverlay,\n    factory: LyOverlay.ɵfac\n  });\n  return LyOverlay;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LyOverlayModule = /*#__PURE__*/(() => {\n  class LyOverlayModule {}\n\n  LyOverlayModule.ɵfac = function LyOverlayModule_Factory(t) {\n    return new (t || LyOverlayModule)();\n  };\n\n  LyOverlayModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LyOverlayModule\n  });\n  LyOverlayModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [LyOverlay]\n  });\n  return LyOverlayModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst STYLES_BACKDROP_DARK = {\n  backgroundColor: 'rgba(0,0,0,.32)'\n};\nconst MUTATION_OBSERVER_INIT = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nlet MutationObserverFactory = /*#__PURE__*/(() => {\n  class MutationObserverFactory {\n    create(callback) {\n      return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\n    }\n\n  }\n\n  MutationObserverFactory.ɵfac = function MutationObserverFactory_Factory(t) {\n    return new (t || MutationObserverFactory)();\n  };\n\n  MutationObserverFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MutationObserverFactory,\n    factory: MutationObserverFactory.ɵfac,\n    providedIn: 'root'\n  });\n  return MutationObserverFactory;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ElementObserver = /*#__PURE__*/(() => {\n  class ElementObserver {\n    constructor(_mutationObserverFactory) {\n      this._mutationObserverFactory = _mutationObserverFactory;\n      this._observedElements = new Map();\n    }\n\n    ngOnDestroy() {\n      this._observedElements.forEach((_, element) => this.destroy(element));\n    }\n\n    observe(elementOrRef, fn, options) {\n      const element = elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;\n\n      if (!this._observedElements.has(element)) {\n        const observer = this._mutationObserverFactory.create(fn);\n\n        if (observer) {\n          observer.observe(element, options || MUTATION_OBSERVER_INIT);\n        }\n\n        this._observedElements.set(element, observer);\n      }\n\n      return this._observedElements.get(element);\n    }\n    /**\n     * Destroy Observer\n     */\n\n\n    destroy(elementOrRef) {\n      const element = elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;\n\n      if (this._observedElements.has(element)) {\n        const observer = this._observedElements.get(element);\n\n        if (observer) {\n          this._observedElements.get(element).disconnect();\n        }\n\n        this._observedElements.delete(element);\n      }\n    }\n\n  }\n\n  ElementObserver.ɵfac = function ElementObserver_Factory(t) {\n    return new (t || ElementObserver)(i0.ɵɵinject(MutationObserverFactory));\n  };\n\n  ElementObserver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ElementObserver,\n    factory: ElementObserver.ɵfac,\n    providedIn: 'root'\n  });\n  return ElementObserver;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @deprecated use ViewportRuler instead\n * import { ViewportRuler } from '@angular/cdk/scrolling';\n */\n\n\nlet WinResize = /*#__PURE__*/(() => {\n  class WinResize {\n    constructor(document, ngZone) {\n      this.document = document;\n\n      if (Platform.isBrowser) {\n        ngZone.runOutsideAngular(() => {\n          this.resize$ = fromEvent(window, 'resize').pipe(auditTime(20), map(() => {\n            return window.innerHeight || this.document.documentElement.clientHeight;\n          }), share());\n        });\n      } else {\n        this.resize$ = empty();\n      }\n    }\n\n  }\n\n  WinResize.ɵfac = function WinResize_Factory(t) {\n    return new (t || WinResize)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.NgZone));\n  };\n\n  WinResize.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: WinResize,\n    factory: WinResize.ɵfac,\n    providedIn: 'root'\n  });\n  return WinResize;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @deprecated use ScrollDispatcher instead\n * import { ScrollDispatcher } from '@angular/cdk/scrolling';\n */\n\n\nlet WinScroll = /*#__PURE__*/(() => {\n  class WinScroll {\n    constructor(_document, ngZone) {\n      this._document = _document;\n\n      if (Platform.isBrowser) {\n        ngZone.runOutsideAngular(() => {\n          this.scroll$ = fromEvent(window.document, 'scroll').pipe(auditTime(20), map(() => {\n            return window.scrollY || this._document.documentElement.scrollTop;\n          }), share());\n        });\n      } else {\n        this.scroll$ = empty();\n      }\n    }\n\n  }\n\n  WinScroll.ɵfac = function WinScroll_Factory(t) {\n    return new (t || WinScroll)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.NgZone));\n  };\n\n  WinScroll.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: WinScroll,\n    factory: WinScroll.ɵfac,\n    providedIn: 'root'\n  });\n  return WinScroll;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass LyOverlayPosition {\n  constructor(_theme, _viewportRuler, _trigger, _overlay) {\n    this._theme = _theme;\n    this._viewportRuler = _viewportRuler;\n    this._trigger = _trigger;\n    this._overlay = _overlay;\n    this._xAxis = XPosition.after;\n    this._yAxis = YPosition.below;\n    this._flip = false;\n    this._viewportOffset = 16;\n    this._viewportHeight = 0;\n    this._viewportWidth = 0;\n    this._xOffset = 0;\n    this._yOffset = 0;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  get xo() {\n    return this._xo;\n  }\n\n  get yo() {\n    return this._yo;\n  }\n\n  get width() {\n    return this._width;\n  }\n\n  get height() {\n    return this._height;\n  }\n\n  get triggerRect() {\n    return this._triggerRect;\n  }\n  /** Returns x, but not rounded */\n\n\n  get rawX() {\n    return this._rawX;\n  }\n  /** Returns y, but not rounded */\n\n\n  get rawY() {\n    return this._rawY;\n  }\n\n  build() {\n    this._updateRects();\n\n    this._setDefaultAnchor();\n\n    this._updateDir();\n\n    this._callTransformIfExists();\n\n    this._calculateResponsive();\n\n    this._calculateOrigin();\n\n    this._round();\n\n    return this;\n  }\n\n  _updateRects() {\n    this._triggerRect = getMutableClientRect(this._trigger);\n    this._overlayRect = getMutableClientRect(this._overlay);\n\n    const {\n      width,\n      height\n    } = this._viewportRuler.getViewportSize();\n\n    this._viewportWidth = width;\n    this._viewportHeight = height;\n  }\n\n  _setDefaultAnchor() {\n    if (!this._xAnchor) {\n      this._xAnchor = this._xAxis === XPosition.after ? XPosition.before : XPosition.after;\n    }\n\n    if (!this._yAnchor) {\n      this._yAnchor = this._yAxis;\n    }\n  }\n\n  _callTransformIfExists() {\n    if (this._transform) {\n      this._transform(this._triggerRect, this._overlayRect);\n    }\n  }\n\n  _updateDir() {\n    // If it is not number\n    if (typeof this._xAnchor !== 'number') {\n      this._anchorDir = this._theme.variables.getDirection(this._xAnchor);\n    }\n\n    this._axisDir = this._theme.variables.getDirection(this._xAxis);\n  }\n\n  _calculateResponsive() {\n    this._calculate();\n\n    if (this._flip && typeof this._xAnchor === 'string' && typeof this._yAnchor === 'string') {\n      if (this._isOverflowX() && this._overlayRect.width < this._xa - this._viewportOffset) {\n        this.setXAxis(flipPosition(this._xAxis)).setXAnchor(flipPosition(this._xAnchor));\n\n        this._updateDir();\n\n        this._calculate();\n      }\n\n      if (this._isOverflowY() && this._overlayRect.height < this._ya - this._viewportOffset) {\n        this.setYAxis(flipPosition(this._yAxis)).setYAnchor(flipPosition(this._yAnchor));\n\n        this._calculate();\n      }\n    }\n\n    if (this._isOverflowX()) {\n      if (this._overlayRect.width > this._viewportWidth - this._viewportOffset * 2) {\n        this._x = this._viewportOffset;\n        this._width = this._viewportWidth - this._viewportOffset * 2;\n      } else if (this._isOverflowLeft()) {\n        this._x = this._viewportOffset;\n      } else if (this._isOverflowRight()) {\n        this._x = this._viewportWidth - this._overlayRect.width - this._viewportOffset;\n      }\n    }\n\n    if (this._isOverflowY()) {\n      if (this._overlayRect.height > this._viewportHeight - this._viewportOffset * 2) {\n        this._y = this._viewportOffset;\n        this._height = this._viewportHeight - this._viewportOffset * 2;\n      } else if (this._isOverflowTop()) {\n        this._y = this._viewportOffset;\n      } else if (this._isOverflowBottom()) {\n        this._y = this._viewportHeight - this._overlayRect.height - this._viewportOffset;\n      }\n    }\n  }\n  /**\n   * Return true if the menu overflows vertically\n   */\n\n\n  _isOverflowX() {\n    return this._isOverflowLeft() // Left\n    || this._isOverflowRight(); // Right\n  }\n\n  _isOverflowLeft() {\n    return this.x < this._viewportOffset;\n  }\n\n  _isOverflowRight() {\n    return this.x + this._overlayRect.width > this._viewportWidth - this._viewportOffset;\n  }\n  /** Return true the menu overflows horizontally */\n\n\n  _isOverflowY() {\n    return this._isOverflowTop() // Top\n    || this._isOverflowBottom(); // Bottom\n  }\n\n  _isOverflowTop() {\n    return this.y < this._viewportOffset;\n  }\n\n  _isOverflowBottom() {\n    return this.y + this._overlayRect.height > this._viewportHeight - this._viewportOffset;\n  }\n\n  _calculate() {\n    this._calculateAnchorPosition();\n\n    this._calculateAxis();\n  }\n\n  _calculateAnchorPosition() {\n    this._xa = this._triggerRect[this._anchorDir];\n\n    if (this._yAnchor === YPosition.above) {\n      this._ya = this._triggerRect.top;\n    } else {\n      this._ya = this._triggerRect.bottom;\n    } // apply offset with support for rtl\n\n\n    if (this._anchorDir === 'left') {\n      this._xa += this._xOffset;\n    } else {\n      this._xa -= this._xOffset;\n    }\n\n    this._ya += this._yOffset;\n  }\n\n  _calculateAxis() {\n    if (this._axisDir === 'left') {\n      this._x = this._xa - this._overlayRect.width;\n    } else {\n      this._x = this._xa;\n    }\n\n    if (this._yAxis === YPosition.above) {\n      this._y = this._ya - this._overlayRect.height;\n    } else {\n      this._y = this._ya;\n    }\n  }\n  /** Calculate origin for overlay */\n\n\n  _calculateOrigin() {\n    const xAnchorCenter = this._xa - this._xOffset;\n    const yAnchorCenter = this._ya - this._yOffset;\n    const xOverlayCenter = this.x + this._overlayRect.width / 2;\n    const yOverlayCenter = this.y + this._overlayRect.height / 2;\n    const xo = xAnchorCenter - xOverlayCenter + this._overlayRect.width / 2;\n    const yo = yAnchorCenter - yOverlayCenter + this._overlayRect.height / 2;\n    this._xo = xo;\n    this._yo = yo;\n  }\n\n  _round() {\n    this._rawX = this.x;\n    this._rawY = this.y;\n    this._x = Math.round(this.x);\n    this._y = Math.round(this.y);\n  } // setTrigger(val: Element) {\n  //   this._trigger = val;\n  //   return this;\n  // }\n  // setOverlay(val: Element) {\n  //   this._overlay = val;\n  //   return this;\n  // }\n\n\n  setXAnchor(val) {\n    this._xAnchor = val;\n    return this;\n  }\n\n  setYAnchor(val) {\n    this._yAnchor = val;\n    return this;\n  }\n\n  setXAxis(val) {\n    this._xAxis = val !== null && val !== void 0 ? val : XPosition.after;\n    return this;\n  }\n\n  setYAxis(val) {\n    this._yAxis = val !== null && val !== void 0 ? val : YPosition.below;\n    return this;\n  }\n\n  setFlip(flip = true) {\n    this._flip = flip;\n    return this;\n  }\n\n  setXOffset(val) {\n    this._xOffset = val;\n    return this;\n  }\n\n  setYOffset(val) {\n    this._yOffset = val;\n    return this;\n  }\n  /**\n   * Offset from the edge of the viewport to the center.\n   * It is the minimum space that must be between the window and the overlay.\n   */\n\n\n  setViewportOffset(val) {\n    this._viewportOffset = val;\n    return this;\n  }\n\n  setTransform(transform) {\n    this._transform = transform;\n    return this;\n  }\n\n}\n/** Gets a mutable version of an element's bounding `ClientRect`. */\n\n\nfunction getMutableClientRect(element) {\n  const clientRect = element.getBoundingClientRect(); // We need to clone the `clientRect` here, because all the values on it are readonly\n  // and we need to be able to update them. Also we can't use a spread here, because\n  // the values on a `ClientRect` aren't own properties. See:\n  // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n\n  return {\n    top: clientRect.top,\n    right: clientRect.right,\n    bottom: clientRect.bottom,\n    left: clientRect.left,\n    width: clientRect.width,\n    height: clientRect.height\n  };\n}\n\nfunction flipPosition(position) {\n  switch (position) {\n    case XPosition.after:\n      return XPosition.before;\n\n    case XPosition.before:\n      return XPosition.after;\n\n    case XPosition.left:\n      return XPosition.right;\n\n    case XPosition.right:\n      return XPosition.left;\n\n    case YPosition.above:\n      return YPosition.below;\n\n    case YPosition.below:\n      return YPosition.above;\n  }\n}\n\nvar AlignAlias = /*#__PURE__*/(() => {\n  (function (AlignAlias) {\n    AlignAlias[\"rowReverse\"] = \"row-reverse\";\n    AlignAlias[\"columnReverse\"] = \"column-reverse\";\n    AlignAlias[\"wrapReverse\"] = \"wrap-reverse\";\n    AlignAlias[\"start\"] = \"flex-start\";\n    AlignAlias[\"end\"] = \"flex-end\";\n    AlignAlias[\"between\"] = \"space-between\";\n    AlignAlias[\"around\"] = \"space-around\";\n    AlignAlias[\"evenly\"] = \"space-evenly\";\n  })(AlignAlias || (AlignAlias = {}));\n\n  return AlignAlias;\n})();\n\nfunction same(o) {\n  return o;\n}\n\nclass LySelectionModel {\n  constructor(opts) {\n    this._selectionMap = new Map();\n    this._getKeyFn = same;\n\n    if (!opts) {\n      return;\n    }\n\n    const {\n      multiple,\n      getKey\n    } = opts;\n\n    if (getKey) {\n      this._getKeyFn = getKey;\n    }\n\n    if (multiple === true) {\n      this._multiple = true;\n      const {\n        selecteds\n      } = opts;\n\n      if (Array.isArray(selecteds) && selecteds.length) {\n        this.select(...selecteds);\n      }\n    } else {\n      const {\n        selecteds\n      } = opts;\n\n      if (selecteds) {\n        this._markSelected(selecteds);\n      }\n    }\n  }\n  /** Selected values. */\n\n\n  get selected() {\n    if (!this._selected) {\n      this._selected = Array.from(this._selectionMap.values());\n    }\n\n    return this._selected;\n  }\n  /**\n   * Toggles a value between selected and deselected.\n   */\n\n\n  toggle(value) {\n    this.isSelected(value) ? this.deselect(value) : this.select(value);\n  }\n  /**\n   * Selects one or several values.\n   */\n\n\n  select(...values) {\n    values.forEach(value => this._markSelected(value));\n\n    this._clearSelectedValues();\n  }\n  /**\n   * Deselects a value or an array of values.\n   */\n\n\n  deselect(...values) {\n    values.forEach(value => this._unmarkSelected(value));\n\n    this._clearSelectedValues();\n  }\n  /**\n   * Determines whether a value is selected.\n   */\n\n\n  isSelected(value) {\n    const key = this._getKeyFn(value);\n\n    return this._selectionMap.has(key);\n  }\n  /**\n   * Determines whether the model does not have a value.\n   */\n\n\n  isEmpty() {\n    return this._selectionMap.size === 0;\n  }\n  /**\n   * Determines whether the model has a value.\n   */\n\n\n  hasValue() {\n    return this._selectionMap.size !== 0;\n  }\n  /**\n   * Gets whether multiple values can be selected.\n   */\n\n\n  isMultipleSelection() {\n    return this._multiple;\n  }\n  /**\n   * Clears all of the selected values.\n   */\n\n\n  clear() {\n    this._unmarkAll();\n\n    this._clearSelectedValues();\n  }\n  /** Selects a value. */\n\n\n  _markSelected(value) {\n    if (!this.isSelected(value)) {\n      if (!this._multiple) {\n        this._unmarkAll();\n      }\n\n      const key = this._getKeyFn(value);\n\n      this._selectionMap.set(key, value);\n    }\n  }\n  /** Deselects a value. */\n\n\n  _unmarkSelected(value) {\n    if (this.isSelected(value)) {\n      const key = this._getKeyFn(value);\n\n      this._selectionMap.delete(key);\n    }\n  }\n  /** Clears out the selected values. */\n\n\n  _unmarkAll() {\n    if (!this.isEmpty()) {\n      this._selectionMap.clear();\n    }\n  }\n  /** Clear the selected values so they can be re-cached. */\n\n\n  _clearSelectedValues() {\n    this._selected = null;\n  }\n\n}\n\nfunction getLyThemeVariableUndefinedError(variable) {\n  return Error(`Variable '${variable}' undefined in Theme.`);\n}\n\nfunction getLyThemeVariableOptionUndefinedError(comp, variable) {\n  return Error(`${comp}: variable ${variable} is undefined in Theme.`);\n}\n\nfunction getLyThemeStyleUndefinedError(comp, input, val) {\n  return Error(`${comp}: no styles defined in the theme have been found for \\`@Input() ${input}\\`,` + ` the value given is \\`${val}\\`.`);\n}\n\nconst STYLES = (theme, ref) => {\n  const __ = ref.selectorsOf(STYLES);\n\n  return {\n    root: _className => `${_className}{width:1em;height:1em;display:inline-block;position:relative;font-size:24px;}`,\n    line: _className => `${_className}{top:calc(0.5em - 1px);position:absolute;width:${1 / 3}em;height:2px;background-color:currentColor;display:inline-block;transition:all ${theme.animations.durations.entering}ms ${theme.animations.curves.standard};}${_className}:first-of-type{left:0.25em;-webkit-transform:rotate(45deg);transform:rotate(45deg);}${_className}:last-of-type{right:0.25em;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);}`,\n    up: () => _className => `${_className} ${__.line}:first-of-type{-webkit-transform:rotate(-45deg);transform:rotate(-45deg);}${_className} ${__.line}:last-of-type{-webkit-transform:rotate(45deg);transform:rotate(45deg);}`\n  };\n};\n\nlet LyExpansionIcon = /*#__PURE__*/(() => {\n  class LyExpansionIcon {\n    constructor(sRenderer, _theme, _renderer, _el) {\n      this.sRenderer = sRenderer;\n      this._theme = _theme;\n      this._renderer = _renderer;\n      this._el = _el;\n      this.classes = this.sRenderer.renderSheet(STYLES, true);\n      this._up = false;\n    }\n\n    set color(val) {\n      this._colorClass = this._theme.addStyle('LyExpansionIcon.color', theme => ({\n        '{line}': {\n          backgroundColor: theme.colorOf(val)\n        }\n      }), this._el.nativeElement, this._colorClass, null, STYLES);\n    }\n\n    get color() {\n      return this._color;\n    }\n\n    set up(val) {\n      const newVal = toBoolean(val);\n\n      if (newVal !== this.up) {\n        this._up = newVal;\n\n        if (newVal) {\n          this._renderer.addClass(this._el.nativeElement, this.classes.up);\n        } else {\n          this._renderer.removeClass(this._el.nativeElement, this.classes.up);\n        }\n      }\n    }\n\n    get up() {\n      return this._up;\n    }\n\n    toggle() {\n      this.up = !this.up;\n    }\n\n  }\n\n  LyExpansionIcon.ɵfac = function LyExpansionIcon_Factory(t) {\n    return new (t || LyExpansionIcon)(i0.ɵɵdirectiveInject(StyleRenderer), i0.ɵɵdirectiveInject(LyTheme2), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  LyExpansionIcon.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: LyExpansionIcon,\n    selectors: [[\"ly-expansion-icon\"]],\n    inputs: {\n      color: \"color\",\n      up: \"up\"\n    },\n    features: [i0.ɵɵProvidersFeature([StyleRenderer])],\n    decls: 2,\n    vars: 2,\n    consts: [[3, \"className\"]],\n    template: function LyExpansionIcon_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"span\", 0)(1, \"span\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"className\", ctx.classes.line);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"className\", ctx.classes.line);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return LyExpansionIcon;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LyExpansionIconModule = /*#__PURE__*/(() => {\n  class LyExpansionIconModule {}\n\n  LyExpansionIconModule.ɵfac = function LyExpansionIconModule_Factory(t) {\n    return new (t || LyExpansionIconModule)();\n  };\n\n  LyExpansionIconModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LyExpansionIconModule\n  });\n  LyExpansionIconModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return LyExpansionIconModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AUI_LAST_UPDATE, AUI_VERSION, AlignAlias, CoreTheme, Dir, DirAlias, DirPosition, ElementObserver, FocusStatus, IS_CORE_THEME, LY_CLASS_NAME_PREFIX, LY_COMMON_STYLES, LY_COMMON_STYLES_DEPRECATED, LY_HAMMER_OPTIONS, LY_THEME, LY_THEME_GLOBAL_VARIABLES, LY_THEME_NAME, LyCommonModule, LyCoreStyles, LyExpansionIcon, LyExpansionIconModule, LyFocusState, LyHammerGestureConfig, LyHostClass, LyOverlay, LyOverlayBackdrop, LyOverlayConfig, LyOverlayContainer, LyOverlayModule, LyOverlayPosition, LyOverlayRef, LyPaper, LyPaperBase, LyPaperMixinBase, LyRippleService, LySelectionModel, LyStyle, LyStyleDeprecated, LyStyleDeprecatedModule, LyStyleUtils, LyTheme2, LyThemeModule, LyWithClass, LylParse, MutationObserverFactory, NgTranscludeDirective, NgTranscludeModule, OverlayFactory, Platform, Positioning, Ripple, STYLES_BACKDROP_DARK, STYLES_BACKDROP_ROOT, Shadows, StringIdGenerator, Style, Style2, StyleCollection, StyleRenderer, StylesInDocument, THEME_VARIABLES, TypeStyle, Undefined, UndefinedValue, WinResize, WinScroll, XPosition, YPosition, _STYLE_MAP, _renderStyle, capitalizeFirstLetter, ck, converterToCssKeyAndStyle, createOverlayInjector, createStyle, defaultEntry, dot, eachMedia, getContrastYIQ, getLyThemeStyleUndefinedError, getLyThemeVariableOptionUndefinedError, getLyThemeVariableUndefinedError, getNativeElement, getThemeNameForSelectors, invertPlacement, keyframesUniqueId, lyl, memoize, mergeDeep, mergeThemes, mixinBg, mixinColor, mixinDisableRipple, mixinDisabled, mixinElevation, mixinOutlined, mixinRaised, mixinShadowColor, mixinStyleUpdater, mixinTabIndex, parseMediaQueriesFromString, parseMediaQueryFromString, resolveSelectors, scrollTo, scrollWithAnimation, shadowBuilder, st2c, supportsPassiveEventListeners, toBoolean, toNumber, untilComponentDestroyed, withMediaInline }; //# sourceMappingURL=alyle-ui.mjs.map","map":null,"metadata":{},"sourceType":"module"}