{"ast":null,"code":"import { __decorate } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Inject, Input, Component, ChangeDetectionStrategy, ViewChild, forwardRef, EventEmitter, Optional, ViewChildren, Output, NgModule } from '@angular/core';\nimport * as i1 from '@alyle/ui';\nimport { untilComponentDestroyed, st2c, LY_COMMON_STYLES, StyleCollection, Dir, StyleRenderer, Style, LyCommonModule } from '@alyle/ui';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { Subject } from 'rxjs';\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\nimport * as i4 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { hasModifierKey, DOWN_ARROW, RIGHT_ARROW, UP_ARROW, LEFT_ARROW, HOME, END, PAGE_DOWN, PAGE_UP } from '@angular/cdk/keycodes';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport * as i2 from '@angular/cdk/a11y';\n/**\n * Used to provide a slider to some of the sub-components without causing a circular dependency.\n * @docs-private\n */\n\nconst _c0 = [\"*\"];\nconst _c1 = [\"wrapper\"];\nconst _c2 = [\"bg\"];\nconst _c3 = [\"track\"];\nconst _c4 = [\"ticksRef\"];\nconst _c5 = [\"thumbsRef\"];\n\nfunction LySlider_ng_template_6_ly_tick_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ly-tick\", 8);\n  }\n\n  if (rf & 2) {\n    const tick_r9 = ctx.$implicit;\n    i0.ɵɵproperty(\"value\", tick_r9);\n  }\n}\n\nfunction LySlider_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, LySlider_ng_template_6_ly_tick_0_Template, 1, 1, \"ly-tick\", 7);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3._tickList);\n  }\n}\n\nfunction LySlider_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\n\nfunction LySlider_ng_template_10_ly_mark_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"ly-mark\", 8);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const mark_r11 = ctx.$implicit;\n    i0.ɵɵproperty(\"value\", mark_r11.value);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(mark_r11.label);\n  }\n}\n\nfunction LySlider_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, LySlider_ng_template_10_ly_mark_0_Template, 2, 2, \"ly-mark\", 7);\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r6._marksList);\n  }\n}\n\nfunction LySlider_div_11_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 0)(1, \"span\", 0);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const thumb_r12 = i0.ɵɵnextContext().$implicit;\n    const ctx_r14 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"className\", ctx_r14.classes.thumbLabel);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"className\", ctx_r14.classes.thumbLabelValue);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(thumb_r12.displayValue);\n  }\n}\n\nfunction LySlider_div_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 9)(1, \"div\", 10, 11);\n    i0.ɵɵlistener(\"focus\", function LySlider_div_11_Template_div_focus_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r17);\n      const thumb_r12 = restoredCtx.$implicit;\n      const ctx_r16 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r16._onFocusThumb(thumb_r12));\n    })(\"blur\", function LySlider_div_11_Template_div_blur_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r17);\n      const thumb_r12 = restoredCtx.$implicit;\n      const ctx_r18 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r18._onBlurThumb(thumb_r12));\n    });\n    i0.ɵɵelement(3, \"div\", 0);\n    i0.ɵɵtemplate(4, LySlider_div_11_div_4_Template, 3, 3, \"div\", 12);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const thumb_r12 = ctx.$implicit;\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"className\", ctx_r7.classes.thumbContainer)(\"ngStyle\", thumb_r12.styles);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"className\", ctx_r7.classes.thumbContent)(\"ngClass\", thumb_r12.focused ? ctx_r7.classes.thumbContentFocused : null);\n    i0.ɵɵattribute(\"tabindex\", ctx_r7.disabled ? -1 : 0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"className\", ctx_r7.classes.thumb);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.thumbVisible !== false);\n  }\n}\n\nconst _c6 = [[[\"ly-mark\"]]];\nconst _c7 = [\"ly-mark\"];\nconst LY_SLIDER = new InjectionToken('LY_SLIDER');\n\nfunction гbetween(x, min, max) {\n  return x >= min && x <= max;\n}\n\nfunction гvalueToPercent(value, min, max) {\n  return (value - min) * 100 / (max - min);\n}\n\nlet LyTick = /*#__PURE__*/(() => {\n  class LyTick {\n    constructor(_renderer, _el, _slider) {\n      this._renderer = _renderer;\n      this._el = _el;\n      this._slider = _slider;\n      /** @docs-private */\n\n      this.classes = this._slider.classes;\n    }\n\n    ngOnChanges() {\n      this._updateTick();\n    }\n\n    ngOnInit() {\n      this._renderer.addClass(this._getHostElement(), this.classes.tick);\n\n      this._slider._changes.pipe(untilComponentDestroyed(this)).subscribe(() => {\n        this._updateTick();\n      });\n    }\n\n    _updateTick() {\n      const min = this._slider._minPercent;\n      const max = this._slider._maxPercent;\n      const className = this._slider.classes.tickActive;\n      const percent = гvalueToPercent(this.value, this._slider.min, this._slider.max);\n\n      const pos = this._slider._calculatePosition(percent);\n\n      if (гbetween(percent, min, max)) {\n        this._tickActiveClass = className;\n\n        this._renderer.addClass(this._el.nativeElement, className);\n      } else if (this._tickActiveClass) {\n        this._tickActiveClass = null;\n\n        this._renderer.removeClass(this._el.nativeElement, className);\n      }\n\n      this._renderer.setStyle(this._getHostElement(), 'bottom', null);\n\n      this._renderer.setStyle(this._getHostElement(), 'left', null);\n\n      this._renderer.setStyle(this._getHostElement(), 'right', null);\n\n      this._renderer.setStyle(this._getHostElement(), pos.style, pos.value);\n    }\n\n    ngOnDestroy() {}\n\n    _getHostElement() {\n      return this._el.nativeElement;\n    }\n\n  }\n\n  LyTick.ɵfac = function LyTick_Factory(t) {\n    return new (t || LyTick)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(LY_SLIDER));\n  };\n\n  LyTick.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LyTick,\n    selectors: [[\"ly-tick\"]],\n    inputs: {\n      value: \"value\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return LyTick;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LyMark = /*#__PURE__*/(() => {\n  class LyMark {\n    constructor(_renderer, _el, _slider) {\n      this._renderer = _renderer;\n      this._el = _el;\n      this._slider = _slider;\n      /** @docs-private */\n\n      this.classes = this._slider.classes;\n\n      _renderer.addClass(_el.nativeElement, _slider.classes.mark);\n    }\n\n    ngOnInit() {\n      this._renderer.insertBefore(this._slider._wrapper.nativeElement, this._tick._getHostElement(), this._slider._ticksRef.nativeElement);\n\n      this._slider._changes.pipe(untilComponentDestroyed(this)).subscribe(() => {\n        this._updateMark();\n      });\n\n      this._updateMark();\n    }\n\n    _updateMark() {\n      const min = this._slider._minPercent;\n      const max = this._slider._maxPercent;\n      const className = this._slider.classes.markActive;\n      const percent = гvalueToPercent(this.value, this._slider.min, this._slider.max);\n\n      const pos = this._slider._calculatePosition(percent);\n\n      if (гbetween(percent, min, max)) {\n        this._markActiveClass = className;\n\n        this._renderer.addClass(this._el.nativeElement, className);\n      } else if (this._markActiveClass) {\n        this._markActiveClass = null;\n\n        this._renderer.removeClass(this._el.nativeElement, className);\n      }\n\n      this._renderer.setStyle(this._getHostElement(), 'bottom', null);\n\n      this._renderer.setStyle(this._getHostElement(), 'left', null);\n\n      this._renderer.setStyle(this._getHostElement(), 'right', null);\n\n      this._renderer.setStyle(this._getHostElement(), pos.style, pos.value);\n    }\n\n    ngOnDestroy() {}\n\n    _getHostElement() {\n      return this._el.nativeElement;\n    }\n\n  }\n\n  LyMark.ɵfac = function LyMark_Factory(t) {\n    return new (t || LyMark)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(LY_SLIDER));\n  };\n\n  LyMark.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: LyMark,\n    selectors: [[\"ly-mark\"]],\n    viewQuery: function LyMark_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(LyTick, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._tick = _t.first);\n      }\n    },\n    inputs: {\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 1,\n    consts: [[3, \"value\"]],\n    template: function LyMark_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelement(0, \"ly-tick\", 0);\n        i0.ɵɵprojection(1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"value\", ctx.value);\n      }\n    },\n    dependencies: [LyTick],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return LyMark;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst activeEventOptions = normalizePassiveListenerOptions({\n  passive: false\n});\nconst LY_SLIDER_DEFAULT_OPTIONS = new InjectionToken('LY_SLIDER_DEFAULT_OPTIONS');\nconst LY_SLIDER_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => LySlider),\n  multi: true\n};\nconst STYLE_PRIORITY = -2;\n\nconst STYLES = (theme, ref) => {\n  const __ = ref.selectorsOf(STYLES);\n\n  const {\n    before,\n    after\n  } = theme;\n  const isRTL = theme.isRTL();\n  return {\n    $priority: STYLE_PRIORITY,\n    root: () => _className => `${_className}{display:inline-block;position:relative;box-sizing:border-box;}${st2c(LY_COMMON_STYLES.fill, `${_className} ${__.bg}`)}${_className} ${__.bg}{margin:auto;}${_className}${__.sliding}{cursor:-webkit-grabbing;cursor:grabbing;}${_className}${__.sliding} ${__.thumb},${_className}${__.sliding} ${__.thumbLabel}{cursor:-webkit-grabbing;cursor:grabbing;}${st2c(theme.slider && theme.slider.root && (theme.slider.root instanceof StyleCollection ? theme.slider.root.setTransformer(fn => fn(__)).css : theme.slider.root(__)), `${_className}`)}`,\n    wrapper: _className => `${_className}{-webkit-print-color-adjust:exact;color-adjust:exact;position:absolute;}`,\n    track: () => _className => `${_className}{position:absolute;margin:auto;}${__.horizontal} ${_className}{transform-origin:${isRTL ? 100 : 0}% 0;}${__.vertical} ${_className}{transform-origin:${isRTL ? 100 : 0}% 100%;}`,\n    bg: null,\n    thumbContainer: _className => `${_className}{width:0;height:0;position:absolute;margin:auto;}`,\n    thumbContent: _className => `${_className}{display:flex;justify-content:center;align-items:center;}`,\n    thumb: _className => `${_className}{position:absolute;width:16px;height:16px;border-radius:50%;outline:0;cursor:-webkit-grab;cursor:grab;transition:${['border-radius', 'transform'].map(prop => `${prop} ${theme.animations.durations.exiting}ms ${theme.animations.curves.standard} 0ms`).join()};}${_className}::before{content:'';}${st2c(LY_COMMON_STYLES.fill, `${_className}::before`)}${_className}::before{border-radius:50%;transition:${['box-shadow'].map(prop => `${prop} ${theme.animations.durations.entering}ms ${theme.animations.curves.sharp} 0ms`).join()};}`,\n    thumbLabel: _className => `${_className}{position:absolute;font-size:12px;width:28px;height:28px;border-radius:50%;top:-14px;${before}:-14px;cursor:-webkit-grab;cursor:grab;transition:${['transform', 'top', 'left', 'right', 'border-radius'].map(prop => `${prop} 150ms ${theme.animations.curves.standard} 0ms`).join()};}`,\n    thumbLabelValue: _className => `${_className}{display:flex;height:100%;width:100%;align-items:center;justify-content:center;}`,\n    horizontal: () => _className => `${_className}{width:128px;height:48px;padding:8px;touch-action:pan-y !important;}${_className} ${__.wrapper}{top:23px;left:8px;right:8px;}${_className} ${__.track},${_className} ${__.bg},${_className} ${__.track}{height:inherit;}${_className} ${__.track},${_className} ${__.bg}{width:100%;}${_className} ${__.track}{${before}:0;top:0;bottom:0;}${_className} ${__.thumbContainer}{top:0;bottom:0;}${_className} ${__.tick}{width:2px;top:0;bottom:0;transform:translate(-1px,0%);}${_className} ${__.mark}{top:22px;transform:translateX(${theme.direction === Dir.ltr ? '-' : ''}50%);}${_className}${__.marked}{margin-bottom:24px;}`,\n    vertical: () => _className => `${_className}{width:48px;height:128px;padding:8px;touch-action:pan-x !important;}${_className} ${__.wrapper}{${before}:23px;top:8px;bottom:8px;}${_className} ${__.track},${_className} ${__.bg},${_className} ${__.track}{width:inherit;}${_className} ${__.track},${_className} ${__.bg}{height:100%;}${_className} ${__.track}{bottom:0;${before}:-1px;${after}:0;}${_className} ${__.thumbContainer}{left:0;right:0;}${_className} ${__.tick}{width:inherit;height:2px;left:0;right:0;}${_className} ${__.mark}{${before}:22px;transform:translateY(50%);}${_className}${__.marked}{${theme.direction === Dir.ltr ? 'margin-right' : 'margin-left'}:24px;}`,\n    marked: null,\n    mark: _className => `${_className}{position:absolute;white-space:nowrap;font-size:14px;color:${theme.text.secondary};}`,\n    markActive: _className => `${_className}{color:currentColor;}`,\n    tick: _className => `${_className}{position:absolute;margin:auto;}`,\n    tickActive: null,\n    thumbVisible: null,\n    thumbNotVisible: null,\n    thumbContentFocused: null,\n    sliding: null,\n    disabled: _className => `${_className}{cursor:default;}`\n  };\n};\n/** A change event emitted by the LySlider component. */\n\n\nclass LySliderChange {\n  constructor(\n  /** The LySlider that changed. */\n  source,\n  /** The new value of the source slider. */\n  value) {\n    this.source = source;\n    this.value = value;\n  }\n\n}\n\nlet LySlider = /*#__PURE__*/(() => {\n  class LySlider {\n    // private _ngClass: NgClass;\n    constructor(_theme, _el, _renderer, _cd, sRenderer, _ngZone, _focusMonitor, _document, _default) {\n      this._theme = _theme;\n      this._el = _el;\n      this._renderer = _renderer;\n      this._cd = _cd;\n      this.sRenderer = sRenderer;\n      this._ngZone = _ngZone;\n      this._focusMonitor = _focusMonitor;\n      this._default = _default;\n      /** The dimensions of the slider. */\n\n      this._sliderDimensions = null;\n      this._step = 1;\n      this.classes = this._theme.renderStyleSheet(STYLES);\n      this._value = null;\n      this._min = 0;\n      this._max = 100;\n      this._changes = new Subject();\n      /**\n       * Whether or not the thumb is sliding.\n       */\n\n      this._isSliding = null;\n      this._thumbs = [];\n      this._rootClasses = new Set();\n      /** Event emitted when the slider value has changed. */\n\n      this.change = new EventEmitter();\n      /** Event emitted when the slider thumb moves. */\n\n      this.input = new EventEmitter();\n      /** @docs-private */\n\n      this.valueChange = new EventEmitter();\n      /** Called when the window has lost focus. */\n\n      this._windowBlur = () => {\n        // If the window is blurred while dragging we need to stop dragging because the\n        // browser won't dispatch the `mouseup` and `touchend` events anymore.\n        if (this._lastPointerEvent) {\n          this._pointerUp(this._lastPointerEvent);\n        }\n      };\n      /**\n       * The registered callback function called when a blur event occurs on the input element.\n       * @docs-private\n       */\n\n\n      this.onTouched = () => {};\n\n      this._controlValueAccessorChangeFn = () => {};\n\n      this._pointerDown = event => {\n        // Don't do anything if the slider is disabled or the\n        // user is using anything other than the main mouse button.\n        if (this.disabled || this._isSliding || !isTouchEvent(event) && event.button !== 0) {\n          return;\n        }\n\n        this._ngZone.run(() => {\n          this._touchId = isTouchEvent(event) ? getTouchIdForSlider(event, this._el.nativeElement) : undefined;\n          const pointerPosition = getPointerPositionOnPage(event, this._touchId);\n\n          if (pointerPosition) {\n            const oldValue = this.value;\n            this._isSliding = 'pointer';\n            this._lastPointerEvent = event;\n            event.preventDefault();\n\n            this._focusHostElement();\n\n            this._onMouseenter(); // Simulate mouseenter in case this is a mobile device.\n\n\n            this._bindGlobalEvents(event);\n\n            this._focusHostElement();\n\n            this._setOnSlideStart();\n\n            this._updateValueFromPosition(pointerPosition.x, pointerPosition.y); // Emit a change and input event if the value changed.\n\n\n            if (!valueEquals(oldValue, this.value)) {\n              this._emitInputEvent();\n\n              this._changes.next();\n            }\n          }\n        });\n      };\n      /**\n      * Called when the user has moved their pointer after\n      * starting to drag. Bound on the document level.\n      */\n\n\n      this._pointerMove = event => {\n        if (this._isSliding === 'pointer') {\n          const pointerPosition = getPointerPositionOnPage(event, this._touchId);\n\n          if (pointerPosition) {\n            // Prevent the slide from selecting anything else.\n            event.preventDefault();\n            const oldValue = this.value;\n            this._lastPointerEvent = event;\n\n            this._updateValueFromPosition(pointerPosition.x, pointerPosition.y); // Native range elements always emit `input` events when the value changed while sliding.\n\n\n            if (!valueEquals(oldValue, this.value)) {\n              this._emitInputEvent();\n\n              this._changes.next();\n            }\n          }\n        }\n      };\n      /** Called when the user has lifted their pointer. Bound on the document level. */\n\n\n      this._pointerUp = event => {\n        if (this._isSliding === 'pointer') {\n          if (!isTouchEvent(event) || typeof this._touchId !== 'number' || // Note that we use `changedTouches`, rather than `touches` because it\n          // seems like in most cases `touches` is empty for `touchend` events.\n          findMatchingTouch(event.changedTouches, this._touchId)) {\n            event.preventDefault();\n\n            this._removeGlobalEvents();\n\n            this._isSliding = null;\n            this._touchId = undefined;\n\n            this._renderer.removeClass(this._el.nativeElement, this.classes.sliding);\n\n            if (!valueEquals(this._valueOnSlideStart, this.value) && !this.disabled) {\n              this._emitChangeEvent();\n\n              this._changes.next();\n            }\n\n            this._thumbsOnSlideStart = null;\n            this._closestIndex = null;\n            this._valueOnSlideStart = this._lastPointerEvent = null;\n          }\n        }\n      };\n\n      this._document = _document;\n\n      _renderer.addClass(_el.nativeElement, this.classes.root);\n\n      _ngZone.runOutsideAngular(() => {\n        const element = _el.nativeElement;\n        element.addEventListener('mousedown', this._pointerDown, activeEventOptions);\n        element.addEventListener('touchstart', this._pointerDown, activeEventOptions);\n      });\n    }\n    /** Whether or not to show the thumb. */\n\n\n    get thumbVisible() {\n      return this._thumbVisible;\n    }\n\n    set thumbVisible(val) {\n      const newVal = val != null ? coerceBooleanProperty(val) : null;\n\n      if (newVal !== this.thumbVisible) {\n        const {\n          thumbVisible: thumbVisibleClass\n        } = this.classes;\n        const {\n          thumbNotVisible: thumbNotVisibleClass\n        } = this.classes;\n        this._thumbVisible = newVal;\n        this.sRenderer.toggleClass(thumbVisibleClass, newVal === true);\n        this.sRenderer.toggleClass(thumbNotVisibleClass, newVal === false);\n      }\n    }\n    /** Whether or not to show the marks, also accepts an array of marks. */\n\n\n    get marks() {\n      return this._marks;\n    }\n\n    set marks(val) {\n      const newVal = coerceBooleanProperty(val);\n\n      if (newVal !== this.marks) {\n        const newClass = this.classes.marked;\n\n        if (newVal) {\n          this._renderer.addClass(this._el.nativeElement, newClass);\n\n          this._marksClass = newClass;\n          this._marks = Array.isArray(val) ? val : newVal;\n        } else if (this._marksClass) {\n          this._marks = false;\n\n          this._renderer.removeClass(this._el.nativeElement, newClass);\n\n          this._marksClass = null;\n        }\n\n        if (Array.isArray(newVal)) {\n          this._marksList = val;\n        } else {\n          this._marksList = null;\n        }\n      }\n    }\n    /** The maximum value that the slider can have. */\n\n\n    get max() {\n      return this._max;\n    }\n\n    set max(v) {\n      this._max = coerceNumberProperty(v, this._max);\n\n      this._updateThumbs();\n\n      this._cd.markForCheck();\n    }\n    /** The minimum value that the slider can have. */\n\n\n    get min() {\n      return this._min;\n    }\n\n    set min(v) {\n      this._min = coerceNumberProperty(v, this._min); // If the value wasn't explicitly set by the user, set it to the min.\n\n      if (this._value === null) {\n        this.value = this._min;\n      }\n\n      this._updateThumbs();\n\n      this._cd.markForCheck();\n    }\n    /** The slider appearance style. */\n\n\n    set appearance(val) {\n      if (val !== this.appearance) {\n        this._appearance = val;\n        this._appearanceClass = this.sRenderer.add(`${LySlider.и}.appearance:${val}`, (theme, ref) => {\n          const classes = ref.selectorsOf(STYLES);\n\n          if (theme.slider && theme.slider.appearance) {\n            const appearance = theme.slider.appearance[val];\n\n            if (appearance) {\n              return appearance instanceof StyleCollection ? appearance.setTransformer(_ => _(classes)).css : appearance(classes);\n            }\n          }\n\n          throw new Error(`${val} not found in theme.slider.appearance`);\n        }, STYLE_PRIORITY, this._appearanceClass);\n      }\n    }\n\n    get appearance() {\n      return this._appearance;\n    }\n    /** Color of Slider */\n\n\n    get color() {\n      return this._color;\n    }\n\n    set color(val) {\n      this._color = val;\n      const styleKey = `${LySlider.и}.color:${val}`;\n\n      const newStyle = (theme, ref) => {\n        const color = theme.colorOf(val);\n        const contrast = theme.colorOf(`${val}:contrast`);\n\n        const __ = ref.selectorsOf(STYLES);\n\n        if (theme.slider && theme.slider.color) {\n          const sliderColor = theme.slider.color;\n\n          if (sliderColor) {\n            return sliderColor instanceof StyleCollection ? sliderColor.setTransformer(_ => _(__, color, contrast)).css : sliderColor(__, color, contrast);\n          }\n        }\n\n        throw new Error(`${val} not found in theme.slider.color`);\n      };\n\n      this._colorClass = this.sRenderer.add(styleKey, newStyle, STYLE_PRIORITY + 1, this._colorClass);\n    }\n    /** Whether the slider is vertical. */\n\n\n    get vertical() {\n      return this._vertical;\n    }\n\n    set vertical(val) {\n      const newVal = coerceBooleanProperty(val);\n      this._vertical = newVal;\n      const newClass = newVal ? this.classes.vertical : this.classes.horizontal;\n      this._verticalClass = this._theme.updateClass(this._el.nativeElement, this._renderer, newClass, this._verticalClass);\n\n      this._updateThumbs();\n\n      this._cd.markForCheck();\n    }\n    /** The values at which the thumb will snap. */\n\n\n    get step() {\n      return this._step;\n    }\n\n    set step(v) {\n      this._step = coerceNumberProperty(v, this._step);\n      this._stepPrecision = this._step % 1 !== 0 ? this._step.toString().split('.')[1].length : null;\n\n      this._cd.markForCheck();\n    }\n    /**\n     * Value of a slider, this can be a number or an array of numbers.\n     * If the array of numbers has more than one value,\n     * then this will create more thumbs\n     */\n\n\n    get value() {\n      return this._value;\n    }\n\n    set value(val) {\n      if (val !== this._value) {\n        const valueIsArray = Array.isArray(val);\n\n        if (typeof val === 'number') {\n          let newValue = Number(val);\n          newValue = newValue === this.min || newValue === this.max ? newValue : parseFloat(newValue.toFixed(this._stepPrecision));\n          this._value = newValue;\n        } else if (valueIsArray && !arrayEquals(this._value, val)) {\n          let newValue = val;\n          newValue = newValue.map(_val => _val === null ? _val : _val === this.min || _val === this.max ? _val : parseFloat(_val.toFixed(this._stepPrecision)));\n          this._value = newValue;\n        }\n\n        this._thumbs = (valueIsArray ? this._value : [this._value]).map((v, index) => {\n          var _a, _b;\n\n          return {\n            index,\n            value: coerceNumberProperty(v, this.min),\n            displayValue: null,\n            percent: null,\n            styles: {},\n            focused: (_b = (_a = this._thumbs) === null || _a === void 0 ? void 0 : _a[index]) === null || _b === void 0 ? void 0 : _b.focused\n          };\n        });\n\n        this._updateThumbs();\n\n        this._cd.markForCheck();\n      }\n    }\n    /** Whether the slider is disabled. */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(val) {\n      const newVal = coerceBooleanProperty(val);\n\n      if (newVal !== this.disabled) {\n        this._disabled = newVal;\n\n        if (newVal) {\n          // TODO: remove promise when color parameter removed\n          Promise.resolve(null).then(() => {\n            // TODO: deprecated\n            const color = this.color;\n            const styleKey = `${LySlider.и}.disabled:${val}-${color}`;\n            let newStyle;\n\n            newStyle = (theme, ref) => {\n              const clr = theme.colorOf(color);\n\n              const __ = ref.selectorsOf(STYLES);\n\n              if (theme.slider && theme.slider.disabled) {\n                const sliderColor = theme.slider.disabled;\n\n                if (sliderColor) {\n                  return sliderColor instanceof StyleCollection ? sliderColor.setTransformer(_ => _(__, clr)).css : sliderColor(__, clr);\n                }\n              }\n\n              throw new Error(`${val} not found in theme.slider.color`);\n            };\n\n            const newClass = this.sRenderer.add(styleKey, newStyle, STYLE_PRIORITY + 1.5, this._disabledClass);\n            this.sRenderer.addClass(this.classes.disabled);\n            this._disabledClass = newClass;\n          });\n        } else if (this._disabledClass) {\n          this.sRenderer.removeClass(this._disabledClass);\n          this.sRenderer.removeClass(this.classes.disabled);\n          this._disabledClass = null;\n        }\n      }\n    }\n    /**\n     * Whether or not to show the thumb label, but if the value is a number,\n     * it will show ticks according to the steps. For example: if you set\n     * 3 ticks with a step of 10, you will draw a tick every 30 values\n     */\n\n\n    get ticks() {\n      return this._ticks;\n    }\n\n    set ticks(val) {\n      const newValue = coerceNumberProperty(val, coerceBooleanProperty(val));\n      this._ticks = newValue;\n    }\n\n    get _tickList() {\n      return this.__tickList;\n    }\n\n    ngOnChanges() {\n      this._updateTickValues();\n\n      this._changes.next();\n    }\n\n    ngOnInit() {\n      this._theme.directionChanged.pipe(untilComponentDestroyed(this)).subscribe(() => {\n        this.ngOnChanges();\n\n        this._updateThumbs();\n\n        this._cd.markForCheck();\n      });\n      /** Set default appearance */\n\n\n      if (this.appearance == null) {\n        this.appearance = this._default && this._default.appearance || 'standard';\n      }\n      /** Set default size */\n\n\n      if (this.size == null) {\n        this.size = 'small';\n      }\n      /** Set horizontal slider */\n\n\n      if (this.vertical == null) {\n        this.vertical = false;\n      }\n      /** Set default color */\n\n\n      if (this.color == null) {\n        this.color = 'accent';\n      }\n      /** Set default step */\n\n\n      if (this.step == null) {\n        this.step = 1;\n      }\n    }\n\n    ngAfterViewInit() {\n      this._focusMonitor.monitor(this._el, true).subscribe(_origin => {\n        this._cd.detectChanges();\n      });\n    }\n\n    ngOnDestroy() {\n      const element = this._el.nativeElement;\n\n      this._focusMonitor.stopMonitoring(this._el);\n\n      element.removeEventListener('mousedown', this._pointerDown, activeEventOptions);\n      element.removeEventListener('touchstart', this._pointerDown, activeEventOptions);\n      this._lastPointerEvent = null;\n\n      this._changes.complete();\n    }\n\n    writeValue(value) {\n      this.value = value;\n\n      this._changes.next();\n    }\n    /**\n     * Registers a function called when the control value changes.\n     *\n     * @param fn The callback function\n     */\n\n\n    registerOnChange(fn) {\n      this._controlValueAccessorChangeFn = fn;\n    }\n    /**\n     * Registers a function called when the control is touched.\n     *\n     * @param fn The callback function\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /**\n     * Disables the select. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param isDisabled Sets whether the component is disabled.\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n\n    _onMouseenter() {\n      if (this.disabled) {\n        return;\n      } // We save the dimensions of the slider here so we can use them to update the spacing of the\n      // ticks and determine where on the slider click and slide events happen.\n\n\n      this._sliderDimensions = this._getSliderDimensions(); // this._updateTickIntervalPercent();\n    }\n\n    _onFocus() {\n      // We save the dimensions of the slider here so we can use them to update the spacing of the\n      // ticks and determine where on the slider click and slide events happen.\n      this._sliderDimensions = this._getSliderDimensions(); // this._updateTickIntervalPercent();\n    }\n\n    _onBlur() {\n      this.onTouched();\n    }\n\n    _onKeydown(event) {\n      if (this.disabled || hasModifierKey(event) || this._isSliding && this._isSliding !== 'keyboard') {\n        return;\n      }\n\n      this._isSliding = 'keyboard';\n      const oldValue = this.value;\n\n      switch (event.keyCode) {\n        case PAGE_UP:\n          this._increment(10);\n\n          break;\n\n        case PAGE_DOWN:\n          this._increment(-10);\n\n          break;\n\n        case END:\n          this.value = this.max;\n          break;\n\n        case HOME:\n          this.value = this.min;\n          break;\n\n        case LEFT_ARROW:\n          this._increment(this._getDirection() === Dir.rtl ? 1 : -1);\n\n          break;\n\n        case UP_ARROW:\n          this._increment(1);\n\n          break;\n\n        case RIGHT_ARROW:\n          // See comment on LEFT_ARROW about the conditions under which we flip the meaning.\n          this._increment(this._getDirection() === Dir.rtl ? -1 : 1);\n\n          break;\n\n        case DOWN_ARROW:\n          this._increment(-1);\n\n          break;\n\n        default:\n          // Return if the key is not one that we explicitly handle to avoid calling preventDefault on\n          // it.\n          return;\n      }\n\n      if (!valueEquals(oldValue, this.value)) {\n        this._emitInputEvent();\n\n        this._emitChangeEvent();\n\n        this._changes.next();\n      }\n\n      event.preventDefault();\n    }\n\n    _onKeyup() {\n      if (this._isSliding === 'keyboard') {\n        this._renderer.removeClass(this._el.nativeElement, this.classes.sliding);\n\n        this._isSliding = null;\n        this._thumbsOnSlideStart = null;\n        this._valueOnSlideStart = null;\n        this._closestIndex = null;\n      }\n    }\n\n    _onFocusThumb(thumb) {\n      if (!this.disabled) {\n        thumb.focused = true;\n      }\n    }\n\n    _onBlurThumb(thumb) {\n      if (!this.disabled) {\n        thumb.focused = false;\n      }\n    }\n\n    _setOnSlideStart() {\n      if (!this._valueOnSlideStart) {\n        this._renderer.addClass(this._el.nativeElement, this.classes.sliding); // clone\n\n\n        this._valueOnSlideStart = Array.isArray(this.value) ? this.value.slice(0) : this.value;\n        this._thumbsOnSlideStart = this._thumbs.slice(0).map(t => Object.assign({}, t));\n      }\n    }\n\n    _trackByFn(_index, item) {\n      return item.index;\n    }\n\n    _getDirection() {\n      return this._theme.variables.direction;\n    }\n\n    _updateValueFromPosition(x, y) {\n      if (!this._sliderDimensions) {\n        return;\n      }\n\n      const w = this._sliderDimensions.width;\n      const h = this._sliderDimensions.height;\n      x -= this._sliderDimensions.left;\n      y -= this._sliderDimensions.top;\n      let percent = clamp(this.vertical ? гvalueToPercent(y, 0, h) : гvalueToPercent(x, 0, w), 0, 100);\n\n      if (this.vertical || !this.vertical && this._theme.variables.direction === Dir.rtl) {\n        percent = 100 - percent;\n      }\n\n      let value;\n\n      if (percent === 0) {\n        value = this.min;\n      } else if (percent === 100) {\n        value = this.max;\n      } else {\n        value = this._roundValueToStep(percentToValue(percent, this.min, this.max));\n      }\n\n      if (this._closestIndex == null) {\n        this._closestIndex = findClosest(this._thumbs.map(thumb => thumb.value), value);\n      }\n\n      const currentThumb = this._thumbsOnSlideStart[this._closestIndex];\n      this._slidingThumbValue = currentThumb.value = value;\n\n      if (Array.isArray(this.value)) {\n        this.value = this._thumbsOnSlideStart.map(thumb => thumb.value).sort(ASC);\n      } else {\n        this.value = value;\n      } // focus slidingThumb\n\n\n      const currentSlidingThumb = this._thumbs.find(thumb => thumb.value === value);\n\n      if (currentSlidingThumb) {\n        currentSlidingThumb.focused = true;\n\n        this._thumbsRef.toArray()[currentSlidingThumb.index].nativeElement.focus();\n      }\n    }\n\n    _updateThumbs() {\n      this._thumbs.forEach(thumb => {\n        const val = clamp(thumb.value, this.min, this.max);\n        const percent = гvalueToPercent(val, this.min, this.max);\n\n        const pos = this._calculatePosition(percent);\n\n        thumb.value = val;\n        thumb.displayValue = this._transformValue(val);\n        thumb.percent = percent;\n\n        if (this._isSliding === 'pointer') {\n          thumb.focused = false;\n        }\n\n        thumb.styles = {\n          [pos.style]: pos.value\n        };\n      });\n\n      this._updateTrack();\n    }\n\n    _calculatePosition(percent) {\n      let style;\n      const value = `${percent}%`;\n\n      if (this.vertical) {\n        style = 'bottom';\n      } else {\n        style = this._theme.variables.direction === 'rtl' ? 'right' : 'left';\n      }\n\n      return {\n        style,\n        value\n      };\n    }\n\n    _updateTrack() {\n      const track = this._track;\n      const thumbs = this._thumbs;\n      const thumbsPercents = thumbs.map(thumb => thumb.percent); // const direction = this._theme.variables.direction === 'rtl' ? 'right' : 'left';\n      // const axis = this.vertical ? 'Y' : 'X';\n      // const sign = this._theme.variables.direction === 'rtl' ? '-' : '';\n\n      if (thumbs.length === 1) {\n        thumbsPercents.unshift(0);\n      }\n\n      const minPercent = this._minPercent = Math.min(...thumbsPercents);\n      const maxPercent = this._maxPercent = Math.max(...thumbsPercents);\n      const percent = maxPercent / 100 - minPercent / 100; // const scale = this.vertical ? `1, ${percent}, 1` : `${percent}, 1, 1`;\n\n      const position = this.vertical ? 'height' : 'width';\n      const location = this.vertical ? 'bottom' : this._theme.variables.direction === 'rtl' ? 'right' : 'left';\n\n      if (track) {\n        // track.nativeElement.style.transform = `translate${axis}(${sign}${minPercent}%)`;\n        // track.nativeElement.style.transform = `translate${axis}(${sign}${minPercent}%) scale3d(${scale})`;\n        track.nativeElement.style.width = '';\n        track.nativeElement.style.height = '';\n        track.nativeElement.style.left = '';\n        track.nativeElement.style.right = '';\n        track.nativeElement.style[position] = `${percent * 100}%`;\n        track.nativeElement.style[location] = `${minPercent}%`;\n      }\n    }\n    /** Emits a change event. */\n\n\n    _emitChangeEvent() {\n      this._controlValueAccessorChangeFn(this.value);\n\n      this.valueChange.emit(this.value);\n      this.change.emit(this._createChangeEvent());\n    }\n    /** Emits an input event. */\n\n\n    _emitInputEvent() {\n      this.input.emit(this._createChangeEvent());\n    }\n\n    _createChangeEvent(value = this.value) {\n      return new LySliderChange(this, value);\n    }\n\n    _roundValueToStep(value) {\n      return Number((Math.round(value / this.step) * this.step).toFixed(this._stepPrecision));\n    }\n\n    _transformValue(value) {\n      if (this.displayWith) {\n        return this.displayWith(value);\n      }\n\n      return value;\n    }\n    /** Increments the slider by the given number of steps (negative number decrements). */\n\n\n    _increment(numSteps) {\n      var _a;\n\n      this._setOnSlideStart();\n\n      if (this._closestIndex == null) {\n        this._closestIndex = this._thumbsOnSlideStart.findIndex(_ => _.focused);\n      }\n\n      const index = this._closestIndex;\n      const thumb = this._thumbsOnSlideStart[index];\n      const newValue = clamp((thumb.value || 0) + this.step * numSteps, this.min, this.max);\n      thumb.value = newValue;\n\n      if (Array.isArray(this.value)) {\n        this.value = this._thumbsOnSlideStart.map(_ => _.value).sort(ASC);\n      } else {\n        this.value = newValue;\n      } // focus slidingThumb\n\n\n      const currentSlidingThumb = this._thumbs.find(t => t.value === newValue);\n\n      if (currentSlidingThumb) {\n        currentSlidingThumb.focused = true;\n        (_a = this._thumbsRef) === null || _a === void 0 ? void 0 : _a.forEach((t, i) => {\n          if (i === currentSlidingThumb.index) {\n            t.nativeElement.focus();\n          } else {\n            this._thumbs[i].focused = false;\n          }\n        });\n      }\n    }\n\n    _getHostElement() {\n      return this._el.nativeElement;\n    }\n    /**\n     * Get the bounding client rect of the slider track element.\n     * The track is used rather than the native element to ignore the extra space that the thumb can\n     * take up.\n     */\n\n\n    _getSliderDimensions() {\n      return this._bg ? this._bg.nativeElement.getBoundingClientRect() : null;\n    }\n\n    _updateTickValues() {\n      this.__tickList = [];\n\n      if (!this.ticks || this.step == null) {\n        return false;\n      } else {\n        const ticks = this.ticks;\n        this._tickInterval = typeof ticks === 'number' ? this.step * ticks : this.step;\n        this.__tickList = [];\n        const stepWidth = this._tickInterval;\n        let cu = this.min;\n\n        this.__tickList.push(cu);\n\n        while (cu <= this.max) {\n          cu += stepWidth;\n          const newVal = clamp(cu, this.min, this.max);\n\n          this.__tickList.push(newVal); // Remove duplicate value for next\n\n\n          if (newVal === this.max) {\n            break;\n          }\n        }\n      }\n\n      this._cd.markForCheck();\n    }\n    /**\n     * Focuses the native element.\n     */\n\n\n    _focusHostElement(options) {\n      this._el.nativeElement.focus(options);\n    }\n    /**\n    * Binds our global move and end events. They're bound at the document level and only while\n    * dragging so that the user doesn't have to keep their pointer exactly over the slider\n    * as they're swiping across the screen.\n    */\n\n\n    _bindGlobalEvents(triggerEvent) {\n      // Note that we bind the events to the `document`, because it allows us to capture\n      // drag cancel events where the user's pointer is outside the browser window.\n      const document = this._document;\n      const isTouch = isTouchEvent(triggerEvent);\n      const moveEventName = isTouch ? 'touchmove' : 'mousemove';\n      const endEventName = isTouch ? 'touchend' : 'mouseup';\n      document.addEventListener(moveEventName, this._pointerMove, activeEventOptions);\n      document.addEventListener(endEventName, this._pointerUp, activeEventOptions);\n\n      if (isTouch) {\n        document.addEventListener('touchcancel', this._pointerUp, activeEventOptions);\n      }\n\n      const window = this._getWindow();\n\n      if (typeof window !== 'undefined' && window) {\n        window.addEventListener('blur', this._windowBlur);\n      }\n    }\n    /** Removes any global event listeners that we may have added. */\n\n\n    _removeGlobalEvents() {\n      const document = this._document;\n      document.removeEventListener('mousemove', this._pointerMove, activeEventOptions);\n      document.removeEventListener('mouseup', this._pointerUp, activeEventOptions);\n      document.removeEventListener('touchmove', this._pointerMove, activeEventOptions);\n      document.removeEventListener('touchend', this._pointerUp, activeEventOptions);\n      document.removeEventListener('touchcancel', this._pointerUp, activeEventOptions);\n\n      const window = this._getWindow();\n\n      if (typeof window !== 'undefined' && window) {\n        window.removeEventListener('blur', this._windowBlur);\n      }\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n\n\n    _getWindow() {\n      return this._document.defaultView || window;\n    }\n\n  }\n\n  LySlider.и = 'LySlider';\n\n  LySlider.ɵfac = function LySlider_Factory(t) {\n    return new (t || LySlider)(i0.ɵɵdirectiveInject(i1.LyTheme2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.StyleRenderer), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.FocusMonitor), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(LY_SLIDER_DEFAULT_OPTIONS, 8));\n  };\n\n  LySlider.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: LySlider,\n    selectors: [[\"ly-slider\"]],\n    viewQuery: function LySlider_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c2, 5);\n        i0.ɵɵviewQuery(_c3, 7);\n        i0.ɵɵviewQuery(_c4, 7);\n        i0.ɵɵviewQuery(_c5, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._wrapper = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._bg = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._track = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._ticksRef = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._thumbsRef = _t);\n      }\n    },\n    hostBindings: function LySlider_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function LySlider_focus_HostBindingHandler() {\n          return ctx._onFocus();\n        })(\"blur\", function LySlider_blur_HostBindingHandler() {\n          return ctx._onBlur();\n        })(\"keydown\", function LySlider_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        })(\"keyup\", function LySlider_keyup_HostBindingHandler() {\n          return ctx._onKeyup();\n        })(\"mouseenter\", function LySlider_mouseenter_HostBindingHandler() {\n          return ctx._onMouseenter();\n        })(\"selectstart\", function LySlider_selectstart_HostBindingHandler($event) {\n          return $event.preventDefault();\n        });\n      }\n    },\n    inputs: {\n      thumbVisible: \"thumbVisible\",\n      marks: \"marks\",\n      max: \"max\",\n      min: \"min\",\n      appearance: \"appearance\",\n      size: \"size\",\n      color: \"color\",\n      vertical: \"vertical\",\n      step: \"step\",\n      value: \"value\",\n      disabled: \"disabled\",\n      ticks: \"ticks\",\n      displayWith: \"displayWith\"\n    },\n    outputs: {\n      change: \"change\",\n      input: \"input\",\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"lySlider\"],\n    features: [i0.ɵɵProvidersFeature([LY_SLIDER_CONTROL_VALUE_ACCESSOR, StyleRenderer, {\n      provide: LY_SLIDER,\n      useExisting: LySlider\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c7,\n    decls: 12,\n    vars: 8,\n    consts: [[3, \"className\"], [\"wrapper\", \"\"], [\"bg\", \"\"], [\"track\", \"\"], [3, \"ngIf\"], [\"ticksRef\", \"\"], [3, \"className\", \"ngStyle\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [3, \"value\", 4, \"ngFor\", \"ngForOf\"], [3, \"value\"], [3, \"className\", \"ngStyle\"], [3, \"className\", \"ngClass\", \"focus\", \"blur\"], [\"thumbsRef\", \"\"], [3, \"className\", 4, \"ngIf\"]],\n    template: function LySlider_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c6);\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵelement(2, \"div\", 0, 2)(4, \"div\", 0, 3);\n        i0.ɵɵtemplate(6, LySlider_ng_template_6_Template, 1, 1, \"ng-template\", 4);\n        i0.ɵɵelement(7, \"span\", null, 5);\n        i0.ɵɵtemplate(9, LySlider_ng_template_9_Template, 1, 0, \"ng-template\", 4);\n        i0.ɵɵtemplate(10, LySlider_ng_template_10_Template, 1, 1, \"ng-template\", 4);\n        i0.ɵɵtemplate(11, LySlider_div_11_Template, 5, 7, \"div\", 6);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"className\", ctx.classes.wrapper);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"className\", ctx.classes.bg);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"className\", ctx.classes.track);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.ticks);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.marks);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx._marksList);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx._thumbs)(\"ngForTrackBy\", ctx._trackByFn);\n      }\n    },\n    dependencies: [LyMark, i4.NgIf, i4.NgForOf, LyTick, i4.NgStyle, i4.NgClass],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([Style(val => (theme, ref) => {\n    var _a;\n\n    const slider = ref.selectorsOf(STYLES);\n\n    if ((_a = theme.slider) === null || _a === void 0 ? void 0 : _a.size) {\n      const size = theme.slider.size[val];\n\n      if (size) {\n        return size instanceof StyleCollection ? size.setTransformer(_ => _(slider)).css : size(slider);\n      }\n    }\n\n    throw new Error(`${LySlider.и}: styles theme.checkbox.size is undefined`);\n  }, STYLE_PRIORITY)], LySlider.prototype, \"size\", void 0);\n\n  return LySlider;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction findClosest(values, currentValue) {\n  const {\n    index: closestIndex\n  } = values.reduce((previousValue, value, index) => {\n    const distance = Math.abs(currentValue - value);\n\n    if (previousValue === null || distance < previousValue.distance || distance === previousValue.distance) {\n      return {\n        distance,\n        index\n      };\n    }\n\n    return previousValue;\n  }, null);\n  return closestIndex;\n}\n\nfunction percentToValue(percent, min, max) {\n  return (max - min) * (percent / 100) + min;\n}\n\nfunction arrayEquals(array1, array2) {\n  return Array.isArray(array1) && Array.isArray(array2) && array1.length === array2.length && array1.every((value, index) => value === array2[index]);\n}\n/** Quickly check if two values are equal */\n\n\nfunction valueEquals(value, value2) {\n  if (value === value2) {\n    return true;\n  }\n\n  return arrayEquals(value, value2);\n}\n\nfunction clamp(value, min, max) {\n  if (value < min) {\n    return min;\n  }\n\n  if (value > max) {\n    return max;\n  }\n\n  return value;\n}\n\nfunction ASC(a, b) {\n  return a - b;\n}\n/** Returns whether an event is a touch event. */\n\n\nfunction isTouchEvent(event) {\n  // This function is called for every pixel that the user has dragged so we need it to be\n  // as fast as possible. Since we only bind mouse events and touch events, we can assume\n  // that if the event's name starts with `t`, it's a touch event.\n  return event.type[0] === 't';\n}\n/** Gets the unique ID of a touch that matches a specific slider. */\n\n\nfunction getTouchIdForSlider(event, sliderHost) {\n  for (let i = 0; i < event.touches.length; i++) {\n    const target = event.touches[i].target;\n\n    if (sliderHost === target || sliderHost.contains(target)) {\n      return event.touches[i].identifier;\n    }\n  }\n\n  return undefined;\n}\n/** Gets the coordinates of a touch or mouse event relative to the viewport. */\n\n\nfunction getPointerPositionOnPage(event, id) {\n  let point;\n\n  if (isTouchEvent(event)) {\n    // The `identifier` could be undefined if the browser doesn't support `TouchEvent.identifier`.\n    // If that's the case, attribute the first touch to all active sliders. This should still cover\n    // the most common case while only breaking multi-touch.\n    if (typeof id === 'number') {\n      point = findMatchingTouch(event.touches, id) || findMatchingTouch(event.changedTouches, id);\n    } else {\n      // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n      point = event.touches[0] || event.changedTouches[0];\n    }\n  } else {\n    point = event;\n  }\n\n  return point ? {\n    x: point.clientX,\n    y: point.clientY\n  } : undefined;\n}\n/** Finds a `Touch` with a specific ID in a `TouchList`. */\n\n\nfunction findMatchingTouch(touches, id) {\n  for (let i = 0; i < touches.length; i++) {\n    if (touches[i].identifier === id) {\n      return touches[i];\n    }\n  }\n\n  return undefined;\n}\n\nlet LySliderModule = /*#__PURE__*/(() => {\n  class LySliderModule {}\n\n  LySliderModule.ɵfac = function LySliderModule_Factory(t) {\n    return new (t || LySliderModule)();\n  };\n\n  LySliderModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LySliderModule\n  });\n  LySliderModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, LyCommonModule]]\n  });\n  return LySliderModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { LY_SLIDER_CONTROL_VALUE_ACCESSOR, LY_SLIDER_DEFAULT_OPTIONS, LyMark, LySlider, LySliderChange, LySliderModule, LyTick, STYLES }; //# sourceMappingURL=alyle-ui-slider.mjs.map","map":null,"metadata":{},"sourceType":"module"}